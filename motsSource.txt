/*

New trailer
Constant fade in from black and fade out to black of:
-walk over to Comparer13. Shoot above the hole. Shoot down the ladder, just below the hole.
	-put the first nondiag bullet in from a distance.
-walk over to gargtrap. Fail to do it.
-deleted levels: angelblock, level crossing, gargwalk, megaphone, oldsquare, perpetual motion
-show al of the levels in the screenshots

"

To do:
-emails
-Desura page
-remove level skip buttons

? -particles coming from garg
? -fix bullet-garg interaction bug
? -put the files in better directories; only a worry for people not using Desura.
? -Stelhan's fast computer...
? -Work on last level (mischievous block?)
? -check volumes
? -redo final level glass
? -add a little "look left, look right" to opening
? -demo

? -gargthings transition animation
? -flower transition animation (triangles could go out, then come back in)
? -could have a sound/particle for when angels stop moving without disrupting doppler.
? -make it so you don't have every single background loaded. Load new ones when a level loads.
? -when a particle is on a falling block, it goes down with it
? -animation seams
*/

//on last level, to make them shoot from the sides, have some bitmaps of angels?

//out by 3

//The headers. Big problem: mixer only supports 8 channels, and worst case scenario, you have to play one sound every frame.
//Could just configure it to take away the oldest sound when you need a new slot, no-one'll notice if there's 8 sounds playing.
#include "SDL.h"
#include "SDL_image.h"
#include "SDL_mixer.h"
#include <string>
#include <fstream>

//Screen attributes
const int SCREEN_WIDTH = 400;
const int SCREEN_HEIGHT = 240;
const int SCREEN_BPP = 32;

//The frame rate
const int FRAMES_PER_SECOND = 30;

//The dimensions of the level. So int is pretty sensible.
const int LEVEL_WIDTH = 2048;
const int LEVEL_HEIGHT = 600;

//Tile constants
const int TILE_WIDTH = SCREEN_WIDTH / 100;
const int TILE_HEIGHT = SCREEN_HEIGHT / 60;
const int TOTAL_TILES = LEVEL_WIDTH * LEVEL_HEIGHT / TILE_WIDTH / TILE_HEIGHT;;
const int TILE_SPRITES = 16;

//the number of tiles in a row
const int furlong = LEVEL_WIDTH / TILE_WIDTH;

//The Avatar dimensions.
const int AVATAR_WIDTH = 4 * TILE_WIDTH;
const int AVATAR_HEIGHT = 8 * TILE_HEIGHT;

//Angels. Put these to good use such as in the x+30 stuff or whatever.
const int ANGEL_WIDTH = 7 * TILE_WIDTH;
const int ANGEL_HEIGHT = 7 * TILE_HEIGHT;

/* Just so you know
const int GARGOYLE_WIDTH = 8 * TILE_WIDTH;
const int GARGOYLE_HEIGHT = 8 * TILE_HEIGHT;
*/

//bead constants. 3 because that is the amount you need to corner a free floating angel. And it's kinda the amount that a person can hold in their head
const int TOTAL_BEADS = 2;

//the falling blocks. Different puzzles need different amounts. Current total is 3 because there are 3 beads.
const int TOTAL_STONES = 8;
const int TOTAL_ANGELS = 23;

//The sounds
Mix_Chunk *glock_C = NULL;
Mix_Chunk *glock_D = NULL;
Mix_Chunk *glock_E = NULL;
Mix_Chunk *glock_F = NULL;
Mix_Chunk *glock_G = NULL;
Mix_Chunk *glock_H = NULL;
Mix_Chunk *glock_I = NULL;
Mix_Chunk *glock_J = NULL;

Mix_Chunk *violins[ 8 ];

Mix_Chunk *Drum_F = NULL;
Mix_Chunk *Drum_G = NULL;

Mix_Chunk *noise = NULL;

Mix_Chunk *footstep1 = NULL;
Mix_Chunk *footstep2 = NULL;

Mix_Chunk *ladderstep1 = NULL;
Mix_Chunk *ladderstep2 = NULL;

Mix_Chunk *la = NULL;

Mix_Chunk *laaa = NULL;

Mix_Chunk *drum = NULL;
Mix_Chunk *crotales = NULL;
Mix_Chunk *bass = NULL;

Mix_Chunk *transition = NULL;

Mix_Chunk *beat = NULL;

Mix_Chunk *harmonic = NULL;

//The different tile sprites. Would be efficient to switch block with floor. These would be easier (and look better in the text file) if they were hexadecimal
const int TILE_LEFTHANG = 0;
const int TILE_LEFTWEDGE = 1;
const int TILE_RIGHTHANG = 2;
const int TILE_RIGHTWEDGE = 3;
const int TILE_GLASS = 4;
const int TILE_BLOCK = 5;
const int TILE_FLOOR = 6;

int level;
volatile bool restart;
volatile bool advance;

bool pressedR = 0;
bool pressedDOWN = 0;
bool pressedLEFT = 0;
bool pressedRIGHT = 0;
bool pressedQ = 1;
bool pressedW = 1;
bool pressedE = 1;
bool pressedA = 1;
bool pressedD = 1;
bool pressedZ = 1;
bool pressedX = 1;
bool pressedC = 1;

/* by the way
const int TILE_GARGOYLE = 7;
const int TILE_AVATAR = 8;
const int TILE_SERAPHIM = 9;
*/


//stuff
SDL_Surface *stonepic = NULL;
SDL_Surface *redAngel = NULL;
SDL_Surface *redAngel_bearing = NULL;

//animation frames
SDL_Surface *smoke = NULL;
SDL_Surface *angelrelease = NULL;

//avatar
SDL_Surface *avatarstanding = NULL;
SDL_Surface *avatarrunning = NULL;
SDL_Surface *avatarthrowing = NULL;
SDL_Surface *avatarclimbing = NULL;
SDL_Surface *avataronladder = NULL;
SDL_Surface *avatartorso = NULL;
SDL_Surface *avatarclimbingswinging = NULL;

SDL_Surface *avatarshocked = NULL;

SDL_Surface *avataraccelerating = NULL;

SDL_Surface *openingavatar = NULL;
SDL_Surface *sling = NULL;
SDL_Surface *slingfadein = NULL;

SDL_Surface *stonegoes = NULL;

SDL_Surface *feather = NULL;


SDL_Surface *screen = NULL;
SDL_Surface *tileSheet = NULL;
SDL_Surface *laser = NULL;
SDL_Surface *laser2 = NULL;
SDL_Surface *Angeltop = NULL;
SDL_Surface *Angeltopright = NULL;
SDL_Surface *Angelright = NULL;
SDL_Surface *Angelbottomright = NULL;
SDL_Surface *Angelbottom = NULL;
SDL_Surface *Angelbottomleft = NULL;
SDL_Surface *Angelleft = NULL;
SDL_Surface *Angeltopleft = NULL;

//wings folded in
SDL_Surface *rightfolded = NULL;
SDL_Surface *leftfolded = NULL;

SDL_Surface *wall = NULL; //the pictures of bricks we combine with the screen
SDL_Surface *bigscreen = NULL;
SDL_Surface *transitionstrip = NULL;
SDL_Surface *Crosses = NULL;


//temporary screen for level_transition
SDL_Surface *temp;

SDL_Surface *background = NULL;
SDL_Surface *buttons = NULL;
SDL_Surface *colours = NULL;
SDL_Surface *greencrinkledrhombs = NULL;
SDL_Surface *relativitybg = NULL;

SDL_Surface *stoneglow = NULL;

//all the glass backgrounds
SDL_Surface *glasses[ 100 ];

SDL_Surface *beadpic = NULL;
SDL_Surface *beadpic2 = NULL;
SDL_Surface *beadpic3 = NULL;

//hopefully you can delete these!
SDL_Surface *loading_screen = NULL;
SDL_Surface *black = NULL;

//used to impose surfaces
SDL_Surface *wood;

SDL_Surface *keyQ;
SDL_Surface *keyW;
SDL_Surface *keyE;
SDL_Surface *keyA;
SDL_Surface *keyD;
SDL_Surface *keyZ;
SDL_Surface *keyX;
SDL_Surface *keyC;
SDL_Surface *keyUP;
SDL_Surface *keyDOWN;
SDL_Surface *keyRIGHT;
SDL_Surface *keyLEFT;

SDL_Surface *moving;


//Sprite from the tile sheet
SDL_Rect clips[ TILE_SPRITES ];

//avatar sprites
SDL_Rect standing[ 32 ];
SDL_Rect throwing[ 30 ];
SDL_Rect climbing[ 16 ];
SDL_Rect running[ 16 ];
SDL_Rect climbingswinging[ 16 ];
SDL_Rect vanishclips[ 13 ];

SDL_Rect BeadClips[ 5 ];

SDL_Rect featherclips[ 45 + 73 + 12 + 17 + 60 ];

SDL_Rect floatingclips[ 4 ];

SDL_Rect ControlKeyClips[ 8 ];

SDL_Rect flyingupleftclips[ 6 ];
SDL_Rect flyinguprightclips[ 6 ];
SDL_Rect flyingdownleftclips[ 6 ];
SDL_Rect flyingdownrightclips[ 6 ];

SDL_Rect flyingrightclips[ 6 ];
SDL_Rect flyingleftclips[ 6 ];
SDL_Rect flyingdownclips[ 6 ];
SDL_Rect flyingupclips[ 6 ];

SDL_Rect accelerating[ 48 ];

//particles sprites
SDL_Rect puffclips[ 7 ];
SDL_Rect diagonalsparkclips[ 7 ];

SDL_Rect shockedclips[ 8 ];

SDL_Rect Powerclips[ 12 ];

SDL_Rect CrossesClips[ 45 ];

SDL_Rect GlowClips[ 6 ];

//when the player wants a new bead, one will be put in the array at this location.
int beadcursor = 0;

//makes avatar's animation exceptional
int script = 0;

//then there's the first one.
/*
0: never mind
1: asleep
2: awake
3: getting up
4: standing
5: shocked to see sling (you must be showing another picture in avatar's show function)
6: shocked, looking at sling in hand
*/
int openingscript = 0;

//which foot the avatar is about to put down (which drum note we play
bool foot = 0;

//torusvideo uses this to work out what direction to go in
bool Torusrightward = 0;

//if we want the screen to be shaking.
volatile int shake = 0;

//gets set to 8 above the key's lower limit when you press a button.
Uint8 KeyFadeFrame = 255;

//does avatar not have a bead?
bool NoBeadOverride = 0;

//restartparticle handlers
bool hadprompt13 = 0;
bool hadprompt18 = 0;
bool hadprompt19 = 0;

//which trail particle is to be created
int TrailParticleIndex = 0;

int gargpuffcursor = 0;

//whether the next line to be drawn should be white or yellow
bool white;

const int LAST_LEVEL = 46;

//the levels
char *levels[ LAST_LEVEL + 1 ] = {

	//silly thing coz we start on 1 and we need something to take up zero
	"Data/Levels/other tester.map",

	


	//trainers
	"Data/Levels/Opening.map",

	
	

	//"lazy.map",



	"Data/Levels/Walker.map",
	"Data/Levels/Spiral_square.map",
	"Data/Levels/Spiral_rounded.map",
	"Data/Levels/Spiral_sharp.map",
	"Data/Levels/Octagon.map",
	"Data/Levels/Flower.map",
	"Data/Levels/Blossom.map",

	//circles
	"Data/Levels/loop.map",
	"Data/Levels/Pincer.map",
	//"Pincer2.map",

	//easy assortment. Not that easy though. pinchexhibitor goes here?
	"Data/Levels/Square.map",
	"Data/Levels/Pyramid.map",
	"Data/Levels/Wall.map",

	//the hourglass series
	"Data/Levels/Pointhitter.map",
	"Data/Levels/Torus.map",
	"Data/Levels/Torusclarifier.map",
	"Data/Levels/1bird2stones.map",
	"Data/Levels/2birds1stones.map", //restartable

	//you get TWO restart prompts, any more would habituate people. Have them fade in.

	//two little ones about forcing them together
	
	
	"Data/Levels/Comparer13.map",
	"Data/Levels/Comparer1.map",

	"Data/Levels/lar.map",

	"Data/Levels/Powerbeadtrainer.map",
	"Data/Levels/Powerbeadclarifier.map",
	"Data/Levels/Catchup.map",
	
	"Data/Levels/Powerbead.map",
	"Data/Levels/Relativity.map",
	

	//garg intro + bouncing bead off gargs
	"Data/Levels/Gargler.map",
	"Data/Levels/gargpincer.map",
	"Data/Levels/Momentum.map",
	"Data/Levels/gargbead1.map",
	"Data/Levels/gargbead2.map",
	"Data/Levels/gargbead3.map",
	//gargbead 4 would be possible
	"Data/Levels/Tortoise.map",

	//bit more sophisticated with gargs
	"Data/Levels/Trapper.map",
	
	//setting up transportable patterns
	"Data/Levels/delevatortrainer.map",
	"Data/Levels/delevator.map",	
	
	"Data/Levels/elevator.map",
	//"Gargwalk.map",

	//modulating bead trajectory with gargs
	"Data/Levels/gargtraptrainertrainer.map",
	"Data/Levels/gargtraptrainer.map",
	"Data/Levels/gargtrap.map",

	//the red shift series
	"Data/Levels/Dopplertrainertrainer.map",
	"Data/Levels/Dopplertrainer.map",
	"Data/Levels/Doppleroboe.map",
	"Data/Levels/Dopplersimpler.map",
	"Data/Levels/Doppler.map",	

	"Data/Levels/Finale.map",

	//last vun
	
	};

//The event structure
SDL_Event event;

//The camera
SDL_Rect camera = { 0, 0, SCREEN_WIDTH, SCREEN_HEIGHT };

//the huge array telling what pixels are affected by what. Uint16 may be feasable. It has a 65,000 limit when you need 96,000 so you'd need to do something with quadrants
//Uint16 scheme[ 320 ][ 320 ];

//tells the lines which pixels they affect
bool checkpoints[ 320 ][ 320 ];

//what we use so that we don't have to constantly call getRGB() in graphics
Uint8 glassRGBs[ SCREEN_WIDTH * SCREEN_HEIGHT ][ 3 ];

//The tile
class Tile
{
    private:
    //The attributes of the tile
    SDL_Rect box;

    //The tile type
    int type;

	//if this is true, then a glass sprite will be shown. The only possibility of it being true is if we've got a floor tile and it's NOT a ladder.
	bool floor;

	//if it's a square, nonglass tile, this says whether it's cream or not
	bool cream;

	//if it's square, this randomized variable says which texture to go for.
	Uint8 randomer;

    public:
    //Initializes the variables
    Tile( int x, int y, int tileType, bool ladderize );

	void make_cream();

    //Shows the tile
    void show( bool lead, bool donecreaming );

    //Get the tile type
    int get_type();

    //Get the collision box
    SDL_Rect get_box();
};

class stone;

class particle;

//The avatar
class Avatar
{
    private:
    //The X and Y offsets of the avatar
    int x, y;

	//the number of frames you've been accelerating for, used for animation.
	int acceleratingframes;

	//a number recording the last direction you threw in, used for animation
	int residue;

	//whether you're slowing down.
	bool slowing;

    //The velocity of the avatar
    int xVel, yVel;

	//If this variable is 0, we speed up on framecount % 8 == 0. If it is 1, we speed up on framecount % 8 == 4.
	bool alignment;

	//The amount of frames a direction button has been held down.
	bool rightdown;
	bool leftdown;
	bool updown;
	bool downdown;

	//animation stuff
	bool facingright;
	bool onladder;

    public:
    //Initializes the variables
    Avatar( int Ecks, int Whyy, bool ladder );

	//Takes key presses and adjusts the avatar's velocity. Returns direction if the player wants a new bead
    int handle_input();

	//increases or decreases Vels.
	int Avatar::accel( int Vel, bool buttondown, int framecount );

    //Moves the avatar
    void move( Tile *tiles[], stone *stones[], int framecount );

	//check whether there's a stone that allows walking
	bool stonewalk( stone *stones[], int tile_position );

    //Shows the avatar on the screen
    void show( int frame, int beaddirection, particle *trail[] );

    //Sets the camera over the avatar
    void set_camera();

	void loopify();
};

//forward declaration for movement
class angel;

//The movable blocks that shall fall and dissolve when they hit the ground.
class stone
{
	private:
	//The X and Y offsets of the stone
	int x, y;

	//whether or not the stone is actually here. If it isn't, all the functions that refer to it will just ignore it and its get_ functions will return 0 (so never have levels that get to 0,0)
	bool on;

	//whether or not the stone is moving
	bool moving;

	//whether or not you're just a particle
	int justaparticle;

	//have you eased in?
	int easingin;

	int GlowStrength;
	int GlowVel;

	public:
	//Initializes the variables
	stone( int Ecks, int Whyy );

	//move
	void move( Tile *tiles[], angel *angels[], int framecount );

	//Shows the stone on the screen
	void show( particle *gargpuffs[] );

    //Get the co-ords. Speedup opportunity: make the beads and angels into friend classes or something?
    int get_x();
	int get_y();
	bool get_on();

	//whether or not you're moving
	bool ismoving();

	//in the final level, you need to have your position changed for a special-case reason.
	void loopify();
};

//forward declaration so that we know what to do with the bead argument in AI
class Bead;
class particle;

class angel
{
	private:
	int x, y;

	//the number that says what their wing flapping is synced to; distinguishes them.
	int offset;

	//the last direction you went in
	int apparentdirection;

	//is the angel alive?
	bool on;

	//is there a stone rested on it? Um, do you need this variable?
	bool bearing;

	//whether the angel has thought yet during this frame. It gets turned off by check and, obv. turned on by think.
	bool thought;

	//whether it's a red winged angel that you HAVE to kill
	bool seraphim;

	//gender
	bool male;

	//how far through the beginning animation you are. If it's zero then animation is done.
	int rejuvenated;

	//the directions it is possible to go in
	unsigned char options;

	public:
	//Initialize
	angel( int Ecks, int Whyy, bool sera );

	//decide sprite on "colour", and display
	void show( stone *stones[], int frame );

	//Looks at the positions of all the beads and makes options into what it should be
	void check( int future, Bead *beads[], Tile *tiles[], stone *stones[], angel *angels[] );

	//Works out where it is in relation to avatar. Decides on priority, then calls move.
	void think( Tile *tiles[], stone *stones[], Bead *beads[], angel *angels[] );

	//moves, checks if it's ok. If so returns true, if not moves back and returns false. Should it take in other angels as well? Yes... later though, cripes. Hugging mechanism.
	bool move( int dir, Tile *tiles[], stone *stones[], Bead *beads[], angel *angels[], int *emergencyX, int *emergencyY );

	//checks for various reasons that a move would be bad
	bool angel::collisions( Tile *tiles[], stone *stones[], Bead *beads[], angel *angels[] );

	//Kill the angel
	void kill( angel *angels[], particle *release );

	//you know what
	int get_x();
	int get_y();
	bool get_seraphim();
	bool get_on();
};

//Particle
class particle
{
private:
	//four: final angel, spark, puff, and levelbit
	int type;

	//how far along the animation we are
	int frame;

	//if it’s a puff these are the center, if it’s sparks then these are the origin.
	int x;
	int y;

	//whether this was the last angel, i.e. when the animation completes we change level
	bool final;

	//sparks need somewhere to fly to, puff of smoke needs direction to go in.
	int dir;

	public:
	particle( int ecks, int whyy, int tiep, int dyrr );
	void show( particle *restartparticle = NULL );
	void relocate( int ecks, int whyy, int dyrr, bool end, int finishingEcks, int finishingWhyy );

	void loopify();
};

//The Bead
class Bead
{
	private:
	//The X and Y offsets of the bead
	int x, y;

	//The direction of the bead. With a circle of arrows pointing in, 0 is straight down and it increases clockwise. 8 is the null bead.
	int dir;

	//keeps track of when to make a trail particle
	int TrailCycle;

	public:
	//Initializes the variables
	Bead( int Ecks, int Whyy, int direction ); //would it be faster to pass it one argument and have it work shit out?

	//mooooove, and handle bounces
	bool move( bool prediction, Tile *tiles[], stone *stones[], angel *angels[] );
	bool move( bool prediction, Tile *tiles[], stone *stones[], angel *angels[], particle *spark[], particle *release, int myposition, particle *trail[] );

	void change( int ecks, int whyy, int dyrr );

	//hacky thing we use in the last level
	bool rightplace( bool lastlevel );
	
	//called before making a bead vanish, creates puff of smoke
	void vanish( particle *puff );

	//Move. Add the stones later. Is the compiler fine having two "dir"s?
	friend void angel::check( int future, Bead *beads[], Tile *tiles[], stone *stones[], angel *angels[] );
	friend bool angel::collisions( Tile *tiles[], stone *stones[], Bead *beads[], angel *angels[] );

	//Shows the bead on the screen
	Uint32 show( int colour, int frame );

	void loopify();
};

//The timer
class Timer
{
    private:
    //The clock time when the timer started
    int startTicks;

    //The ticks stored when the timer was paused
    int pausedTicks;

    //The timer status
    bool paused;
    bool started;

    public:
    //Initializes variables
    Timer();

    //The various clock actions
    void start();
    void stop();
    void pause();
    void unpause();

    //Gets the timer's time
    int get_ticks();

    //Checks the status of the timer
    bool is_started();
    bool is_paused();
};



SDL_Surface *load_image( std::string filename )
{
    //The image that's loaded
    SDL_Surface* loadedImage = NULL;

    //The optimized surface that will be used
    SDL_Surface* optimizedImage = NULL;

    //Load the image
    loadedImage = IMG_Load( filename.c_str() );

    //If the image loaded
    if( loadedImage != NULL )
    {
        //Create an optimized surface
        optimizedImage = SDL_DisplayFormat( loadedImage );

        //Free the old surface
        SDL_FreeSurface( loadedImage );

        //If the surface was optimized
        if( optimizedImage != NULL )
        {
            //Color key surface
			if( filename == "animations/tiles.png" ) SDL_SetColorKey( optimizedImage, SDL_SRCCOLORKEY, 0 );
			else SDL_SetColorKey( optimizedImage, SDL_SRCCOLORKEY, SDL_MapRGB( optimizedImage->format, 0, 0xFF, 0xFF ) );
        }
    }

    //Return the optimized surface
    return optimizedImage;
}

void apply_surface( int x, int y, SDL_Surface* source, SDL_Surface* destination, SDL_Rect* clip = NULL )
{
    //Holds offsets
    SDL_Rect offset;

    //Get offsets
    offset.x = x;
    offset.y = y;

    //Blit
    SDL_BlitSurface( source, clip, destination, &offset );
}

bool check_collision( SDL_Rect A, SDL_Rect B )
{
    //The sides of the rectangles
    int leftA, leftB;
    int rightA, rightB;
    int topA, topB;
    int bottomA, bottomB;

    //Calculate the sides of rect A
    leftA = A.x;
    rightA = A.x + A.w;
    topA = A.y;
    bottomA = A.y + A.h;

    //Calculate the sides of rect B
    leftB = B.x;
    rightB = B.x + B.w;
    topB = B.y;
    bottomB = B.y + B.h;

    //If any of the sides from A are outside of B
    if( bottomA <= topB )
    {
        return false;
    }

    if( topA >= bottomB )
    {
        return false;
    }

    if( rightA <= leftB )
    {
        return false;
    }

    if( leftA >= rightB )
    {
        return false;
    }

    //If none of the sides from A are outside B
    return true;
}

//in addition to inflating, this also does the screen shake effect
void Increase(SDL_Surface *dest, SDL_Surface *source, Uint8 scale)
{
	//source is selected based on scale, we need the smaller
	Uint32 *small = (Uint32 *)source->pixels;
	Uint32 *big = (Uint32 *)dest->pixels;

	Uint8 y, i, j;
	Uint16 x, skip;

	//use this to make sure lines line up
	skip = 800 - scale * SCREEN_WIDTH;

	bool sourceXoffset = 0;
	bool destXoffset = 0;
	bool sourceYoffset = 0;
	bool destYoffset = 0;

	//if you're 12, you're doing a full shake.
	if( shake == 9 ) { sourceXoffset = 1; }
	if( shake == 10 ) { sourceYoffset = 1; }
	if( shake == 11 ) { destXoffset = 1; }
	if( shake == 12 ) { destYoffset = 1; }

	//these are for bullets
	/*
	if( shake == 1 ) { destXoffset = 1; }
	if( shake == 2 ) { destXoffset = 1; destYoffset = 1; }
	if( shake == 3 ) { destYoffset = 1; }
	if( shake == 4 ) { sourceXoffset = -1; destYoffset = 1; }
	if( shake == 5 ) { sourceXoffset = -1; }
	if( shake == 6 ) { sourceXoffset = -1; sourceYoffset = -1; }
	if( shake == 7 ) { sourceYoffset = -1; }
	if( shake == 8 ) { destXoffset = 1; sourceYoffset = -1; }
	*/

	//make sure it progresses or completes.
	if( shake <= 9 ) shake = 0;
	else shake--;

	//you can easily multithread this

    for ( y = sourceYoffset; y < SCREEN_HEIGHT - destYoffset; y++ )
    {
        for ( x = sourceXoffset; x < SCREEN_WIDTH - destXoffset; x++ )
        {
			//so we've got a pixel from the source. Now we put sixteen of them in the approrpriate place in destination.
			for( j = 0; j < scale; j++ )
			{
				for( i = 0; i < scale; i++ )
				{ //+ skip * (y*scale+j) to the first index
					big[ ( ((y-sourceYoffset+destYoffset)*scale+j ) * SCREEN_WIDTH * scale ) + (x-sourceXoffset+destXoffset) * scale + i + skip * ((y-sourceYoffset+destYoffset)*scale+j) ]
						= small[ ( y * SCREEN_WIDTH ) + x ];
				}
			}
        }
    }
}
bool init()
{
    //Initialize all SDL subsystems
    if( SDL_Init( SDL_INIT_EVERYTHING ) == -1 )
    {
        return false;
    }

    //Set up the screen
    bigscreen = SDL_SetVideoMode( SCREEN_WIDTH * 2, SCREEN_HEIGHT * 2, SCREEN_BPP, SDL_SWSURFACE );
	screen = load_image( "animations/screenstarter.png" );

    //If there was an error in setting up the screen
    if( bigscreen == NULL )
    {
        return false;
    }

    //Initialize SDL_mixer
    if( Mix_OpenAudio( 44100, MIX_DEFAULT_FORMAT, 1, 1024 ) == -1 )
    {
        return false;
    }

    //Set the window caption
    SDL_WM_SetCaption( "Music of the Spheres", NULL );


	//load the loading screen
	loading_screen = load_image( "animations/loading_screen.png" );

	if( loading_screen == NULL )
    {
        return false;
    }

	apply_surface( 0, 0, loading_screen, screen );

	Increase( bigscreen, screen, 2 );

	//show the loading screen
	if( SDL_Flip( bigscreen ) == -1 )
    {
        return false;
    }

	//SDL_Delay( 4300 );

	SDL_FreeSurface( loading_screen );

    //If everything initialized fine
    return true;
}

bool load_files()
{
    //Load the avatar image
    avatarstanding = load_image( "animations/avatar_standinglegs.png" );
	avatarrunning = load_image( "animations/avatar_running.png" );
	avatarthrowing = load_image( "animations/avatar_throwing.png" );
	avatarclimbing = load_image( "animations/avatar_climbing.png" );
	avataronladder = load_image( "animations/avatar_onladder.png" );
	avatartorso = load_image( "animations/avatar_torso.png" );
	avatarclimbingswinging = load_image( "animations/climbing_swinging.png" );
	
	avatarshocked = load_image( "animations/shocked.png" );

	avataraccelerating = load_image( "animations/accelerating.png" );

	slingfadein = load_image( "animations/Beginning2.png" );
	sling = load_image( "animations/Beginning.png" );
	openingavatar = load_image( "animations/standingup.png" );


	stonegoes = load_image( "animations/stonegoes.png" );

	feather = load_image( "animations/feather.png" );

	moving = load_image( "animations/moving.png" );

	

    //Load the background
    background = load_image( "animations/bg.png" );
	buttons = load_image( "Images/lastlevelbg.png" );
	relativitybg = load_image( "Images/relativitybg.png" );
	colours = load_image( "Images/1stbg.png" );
	greencrinkledrhombs = load_image( "Images/Green crinkled rhombs.png" );

	stoneglow = load_image( "animations/stoneglow.png" );

	//backgrounds
	glasses[ 36 ] = load_image( "Images/Orange circles.png" );
	glasses[ 0 ] = load_image( "Images/Pyramid.png" );
	glasses[ 1 ] = load_image( "Images/gargtrapbg.png" );
	glasses[ 2 ] = load_image( "Images/Pincer2bg.png" );
	glasses[ 3 ] = load_image( "Images/Spiral_roundedbg.png" );
	glasses[ 4 ] = load_image( "Images/Doppler.png" );
	glasses[ 5 ] = load_image( "Images/gargpincer.png" );
	glasses[ 6 ] = load_image( "Images/Trapperbg.png" );
	glasses[ 7 ] = load_image( "Images/rectangles for gargler.png" );
	glasses[ 8 ] = load_image( "Images/hourglass.png" );
	glasses[ 9 ] = load_image( "Images/Powerbeadbgs.png" );
	glasses[ 10 ] = load_image( "Images/Wallbg.png" );
	glasses[ 11 ] = load_image( "Images/Loop.png" );
	glasses[ 12 ] = load_image( "Images/Spiral_sharpbg.png" );
	glasses[ 13 ] = load_image( "Images/Pincer.png" );
	glasses[ 14 ] = load_image( "Images/Walker.png" );
	glasses[ 15 ] = load_image( "Images/cloverbg.png" );
	glasses[ 16 ] = load_image( "Images/Squarebg.png" );
	glasses[ 33 ] = load_image( "Images/gargbeadbg.png" );
	glasses[ 25 ] = load_image( "Images/sunnies.png" );
	glasses[ 26 ] = load_image( "Images/Comparers.png" );

	black = load_image( "animations/screenstarter.png" );
	wall = load_image( "animations/screenstarter.png" );
	//screen = load_image( "eraser.png" );
	transitionstrip = load_image( "animations/transitionstrip.png" );
	Crosses = load_image( "animations/Crosses.png" );
	temp = load_image( "animations/loading_screen.png" );

	angelrelease = load_image( "animations/release.png" );

	rightfolded = load_image( "animations/rightwingfolded.png" );
	leftfolded = load_image( "animations/leftwingfolded.png" );

	//load the bead. Sucks that it's an odd number of pixels wide, but that seems to be the right size, and it might serve as a reference to the TRUE location
	beadpic = load_image( "animations/bead.png" );
	beadpic2 = load_image( "animations/bead2.png" );
	beadpic3 = load_image( "animations/bead3.png" );

	//what the heck are the stones? Bejeweled gems? The Ten Commandments? Crucifixes? Something breakable.
	stonepic = load_image( "animations/stone.png" );


	wood = load_image( "animations/bittboxtexture.png" ); //credit Robertas Pezas

	smoke = load_image( "animations/puff.png" );

	//Angel and angel flashes
	redAngel = load_image( "animations/flying.png" );
	redAngel_bearing = load_image( "animations/BearingSeraphim.png" );

	//the one pixel pic used for the laser. Rather silly.
	laser = load_image( "animations/laser.png" );
	laser2 = load_image( "animations/laser2.png" );

	keyUP = load_image( "animations/UPkey.png" );
	keyDOWN = load_image( "animations/DOWNkey.png" );
	keyRIGHT = load_image( "animations/RIGHTkey.png" );
	keyLEFT = load_image( "animations/LEFTkey.png" );
	keyQ = load_image( "animations/Qkey.png" );
	keyW = load_image( "animations/Wkey.png" );
	keyE = load_image( "animations/Ekey.png" );
	keyA = load_image( "animations/Akey.png" );
	keyD = load_image( "animations/Dkey.png" );
	keyZ = load_image( "animations/Zkey.png" );
	keyX = load_image( "animations/Xkey.png" );
	keyC = load_image( "animations/Ckey.png" );

 


	//Load the tile sheet
    tileSheet = load_image( "animations/tiles.png" );
	//SDL_Setalpha




	//Load the sounds
    glock_C = Mix_LoadWAV( "Sounds/glock_Cs.wav" );
	glock_D = Mix_LoadWAV( "Sounds/glock_Ds.wav" );
	glock_E = Mix_LoadWAV( "Sounds/glock_Es.wav" );
	glock_F = Mix_LoadWAV( "Sounds/glock_Fs.wav" );
	glock_G = Mix_LoadWAV( "Sounds/glock_Gs.wav" );
	glock_H = Mix_LoadWAV( "Sounds/glock_Hs.wav" );
	glock_I = Mix_LoadWAV( "Sounds/glock_Is.wav" );
	glock_J = Mix_LoadWAV( "Sounds/glock_Js.wav" );

	noise = Mix_LoadWAV( "Sounds/Soundtrack.wav" ); //return to mp3 would be good, as would breaking up the file

	transition = Mix_LoadWAV( "Sounds/transition 1.wav" );

	la = Mix_LoadWAV( "Sounds/Laa.wav" );
	laaa = Mix_LoadWAV( "Sounds/Laaa.wav" );

	drum = Mix_LoadWAV( "Sounds/Drum_F.wav" ); //put some reverb on the drum and replace?
	crotales = Mix_LoadWAV( "Sounds/La.wav" );
	bass = Mix_LoadWAV( "Sounds/collisioon.wav" );

	beat = Mix_LoadWAV( "Sounds/wum.wav" );

	harmonic = Mix_LoadWAV( "Sounds/batchku.wav" );

	violins[ 0 ] = Mix_LoadWAV( "Sounds/Violin_I.wav" );
	violins[ 1 ] = Mix_LoadWAV( "Sounds/Violin_H.wav" );
	violins[ 2 ] = Mix_LoadWAV( "Sounds/Violin_G.wav" );
	violins[ 3 ] = Mix_LoadWAV( "Sounds/Violin_F.wav" );
	violins[ 4 ] = Mix_LoadWAV( "Sounds/Violin_E.wav" );
	violins[ 5 ] = Mix_LoadWAV( "Sounds/Violin_D.wav" );
	violins[ 6 ] = Mix_LoadWAV( "Sounds/Violin_C.wav" );
	violins[ 7 ] = Mix_LoadWAV( "Sounds/Violin_J.wav" );

	footstep1 = Mix_LoadWAV( "Sounds/foootstep1.wav" );
	footstep2 = Mix_LoadWAV( "Sounds/foootstep2.wav" );

	ladderstep1 = Mix_LoadWAV( "Sounds/ladderstep1.wav" );
	ladderstep2 = Mix_LoadWAV( "Sounds/ladderstep2.wav" );




	Mix_VolumeChunk( footstep1, MIX_MAX_VOLUME );
	Mix_VolumeChunk( footstep2, MIX_MAX_VOLUME );
	Mix_VolumeChunk( ladderstep1, MIX_MAX_VOLUME );
	Mix_VolumeChunk( ladderstep2, MIX_MAX_VOLUME );

	Mix_VolumeChunk( glock_C, 12 );
	Mix_VolumeChunk( glock_D, 12 );
	Mix_VolumeChunk( glock_E, 12 );
	Mix_VolumeChunk( glock_F, 12 );
	Mix_VolumeChunk( glock_G, 12 );
	Mix_VolumeChunk( glock_H, 12 );
	Mix_VolumeChunk( glock_I, 12 );
	Mix_VolumeChunk( glock_J, 12 );

	//Mix_VolumeChunk( noise, 0 );
	Mix_VolumeChunk( transition, 7 );
	Mix_VolumeChunk( la, MIX_MAX_VOLUME / 7 );
	Mix_VolumeChunk( laaa, MIX_MAX_VOLUME / 7 );
	Mix_VolumeChunk( drum, 20 );
	Mix_VolumeChunk( crotales, MIX_MAX_VOLUME / 7 );
	Mix_VolumeChunk( bass, 0 );
	Mix_VolumeChunk( beat, 20 );
	Mix_VolumeChunk( harmonic, 8 );

	Mix_VolumeChunk( noise, 2 );
	
	for( int i = 0; i < 8; i++ ) Mix_VolumeChunk( violins[ i ], 2 );

    //If there was a problem loading the sound effects. Only a few; it makes sense to say the others come along.
    if( ( glock_J == NULL ) || ( glock_C == NULL ) || drum == NULL || crotales == NULL )
    {
        return false;
    }

    //If everything loaded fine
    return true;
}

void clean_up( Tile *tiles[], stone *stones[], Bead *beads[], angel *angels[], particle *feathers[] )
{
    //Free the surfaces
	SDL_FreeSurface( smoke );
	SDL_FreeSurface( moving );
    SDL_FreeSurface( avatarrunning );
	SDL_FreeSurface( avatarstanding );
	SDL_FreeSurface( angelrelease );
	SDL_FreeSurface( avatarthrowing );
	SDL_FreeSurface( avatarclimbing );
	SDL_FreeSurface( avataronladder );
	SDL_FreeSurface( avatartorso );
	SDL_FreeSurface( avatarclimbingswinging );
	SDL_FreeSurface( avatarshocked );
    SDL_FreeSurface( background );
	SDL_FreeSurface( colours );
	SDL_FreeSurface( buttons );
	SDL_FreeSurface( stonepic );
	SDL_FreeSurface( beadpic ); 
	SDL_FreeSurface( beadpic2 ); 
	SDL_FreeSurface( beadpic3 ); 
	SDL_FreeSurface( redAngel );
	SDL_FreeSurface( redAngel_bearing );
	SDL_FreeSurface( laser );
	SDL_FreeSurface( Angeltop );
	SDL_FreeSurface( Angeltopright );
	SDL_FreeSurface( Angelright );
	SDL_FreeSurface( Angelbottomright );
	SDL_FreeSurface( Angelbottom );
	SDL_FreeSurface( Angelbottomleft );
	SDL_FreeSurface( Angelleft );
	SDL_FreeSurface( Angeltopleft );
	SDL_FreeSurface( wood );

	SDL_FreeSurface( temp );

	SDL_FreeSurface( rightfolded );
	SDL_FreeSurface( leftfolded );

	SDL_FreeSurface( keyUP );
	SDL_FreeSurface( keyDOWN );
	SDL_FreeSurface( keyLEFT );
	SDL_FreeSurface( keyRIGHT );
	SDL_FreeSurface( keyQ );
	SDL_FreeSurface( keyW );
	SDL_FreeSurface( keyE );
	SDL_FreeSurface( keyA );
	SDL_FreeSurface( keyD );
	SDL_FreeSurface( keyZ );
	SDL_FreeSurface( keyX );
	SDL_FreeSurface( keyC );
	

	SDL_FreeSurface( black );
	SDL_FreeSurface( bigscreen );

	//Free the sounds
	Mix_FreeChunk( glock_C );
	Mix_FreeChunk( glock_D );
	Mix_FreeChunk( glock_E );
	Mix_FreeChunk( glock_F );
	Mix_FreeChunk( glock_G );
	Mix_FreeChunk( glock_H );
	Mix_FreeChunk( glock_I );
	Mix_FreeChunk( glock_J );
	Mix_FreeChunk( drum );
	Mix_FreeChunk( crotales );
	Mix_FreeChunk( noise );
	Mix_FreeChunk( bass );
	Mix_FreeChunk( la );

	//Free the tiles. Do you also need to free the other objects?
    for( int t = 0; t < TOTAL_TILES; t++ )
    {
        delete tiles[ t ];
    }

	for( int t = 0; t < 32; t++ )
    {
        delete feathers[ t ];
    }

	//Quit SDL_mixer
    Mix_CloseAudio();

    //Quit SDL
    SDL_Quit();
}

//does ALL the animations as well
void clip_sheets()
{
    //Clip the tile sheet
    clips[ TILE_LEFTHANG ].x = 0;
    clips[ TILE_LEFTHANG ].y = 0;
    clips[ TILE_LEFTHANG ].w = TILE_WIDTH;
    clips[ TILE_LEFTHANG ].h = TILE_HEIGHT;

    clips[ TILE_LEFTWEDGE ].x = 0;
    clips[ TILE_LEFTWEDGE ].y = 80;
    clips[ TILE_LEFTWEDGE ].w = TILE_WIDTH;
    clips[ TILE_LEFTWEDGE ].h = TILE_HEIGHT;

    clips[ TILE_RIGHTHANG ].x = 80;
    clips[ TILE_RIGHTHANG ].y = 0;
    clips[ TILE_RIGHTHANG ].w = TILE_WIDTH;
    clips[ TILE_RIGHTHANG ].h = TILE_HEIGHT;

	clips[ TILE_RIGHTWEDGE ].x = 0;
    clips[ TILE_RIGHTWEDGE ].y = 160;
    clips[ TILE_RIGHTWEDGE ].w = TILE_WIDTH;
    clips[ TILE_RIGHTWEDGE ].h = TILE_HEIGHT;

    clips[ TILE_GLASS ].x = 80;
    clips[ TILE_GLASS ].y = 80;
    clips[ TILE_GLASS ].w = TILE_WIDTH * 3; 
    clips[ TILE_GLASS ].h = TILE_HEIGHT * 3;

    clips[ TILE_BLOCK ].x = 80;
    clips[ TILE_BLOCK ].y = 160;
    clips[ TILE_BLOCK ].w = TILE_WIDTH;
    clips[ TILE_BLOCK ].h = TILE_HEIGHT;

    clips[ TILE_FLOOR ].x = 160;
    clips[ TILE_FLOOR ].y = 0;
    clips[ TILE_FLOOR ].w = 4 * TILE_WIDTH;
    clips[ TILE_FLOOR ].h = 9 * TILE_HEIGHT;

	clips[ 7 ].x = 160;
    clips[ 7 ].y = 80;
    clips[ 7 ].w = 6;
    clips[ 7 ].h = 6;

	clips[ 8 ].x = 160;
    clips[ 8 ].y = 160;
    clips[ 8 ].w = 6;
    clips[ 8 ].h = 6;

	clips[ 9 ].x = 240;
    clips[ 9 ].y = 160;
    clips[ 9 ].w = 6;
    clips[ 9 ].h = 6;

	clips[ 10 ].x = 240;
    clips[ 10 ].y = 80;
    clips[ 10 ].w = 6;
    clips[ 10 ].h = 6;

	clips[ 12 ].x = 240;
    clips[ 12 ].y = 0;
    clips[ 12 ].w = 6;
    clips[ 12 ].h = 6;

	//the alternative block textures
	clips[ 13 ].x = 80 + 5;
    clips[ 13 ].y = 160;
    clips[ 13 ].w = 4;
    clips[ 13 ].h = 4;

	clips[ 14 ].x = 80 + 5;
    clips[ 14 ].y = 160 + 5;
    clips[ 14 ].w = 4;
    clips[ 14 ].h = 4;

	clips[ 15 ].x = 80;
    clips[ 15 ].y = 160 + 5;
    clips[ 15 ].w = 4;
    clips[ 15 ].h = 4;

	//disappeared bullet particle effect
	puffclips[ 0 ].x = 0;
	puffclips[ 0 ].y = 0;
	puffclips[ 0 ].w = 8;
	puffclips[ 0 ].h = 8;

	puffclips[ 1 ].x = 8;
	puffclips[ 1 ].y = 0;
	puffclips[ 1 ].w = 8;
	puffclips[ 1 ].h = 8;

	puffclips[ 2 ].x = 16;
	puffclips[ 2 ].y = 0;
	puffclips[ 2 ].w = 8;
	puffclips[ 2 ].h = 8;

	puffclips[ 3 ].x = 24;
	puffclips[ 3 ].y = 0;
	puffclips[ 3 ].w = 8;
	puffclips[ 3 ].h = 8;

	puffclips[ 4 ].x = 32;
	puffclips[ 4 ].y = 0;
	puffclips[ 4 ].w = 8;
	puffclips[ 4 ].h = 8;

	puffclips[ 5 ].x = 40;
	puffclips[ 5 ].y = 0;
	puffclips[ 5 ].w = 8;
	puffclips[ 5 ].h = 8;

	puffclips[ 6 ].x = 48;
	puffclips[ 6 ].y = 0;
	puffclips[ 6 ].w = 8;
	puffclips[ 6 ].h = 8;

	diagonalsparkclips[ 0 ].x = 0;
	diagonalsparkclips[ 0 ].y = 0;
	diagonalsparkclips[ 0 ].w = 4;
	diagonalsparkclips[ 0 ].h = 4;

	//that last animation
	for( int i = 0; i < 4; i++ )
	{
		shockedclips[ i ].x = i * 28;
		shockedclips[ i ].y = 0;
		shockedclips[ i ].w = 28;
		shockedclips[ i ].h = 32;
	}
	for( int i = 4; i < 8; i++ )
	{
		shockedclips[ i ].x = (i-4) * 30;
		shockedclips[ i ].y = 32;
		shockedclips[ i ].w = 30;
		shockedclips[ i ].h = 28;
	}

	for( int i = 0; i < 12; i++ )
	{
		Powerclips[ i ].x = 0;
		Powerclips[ i ].y = 6 * i;
		Powerclips[ i ].w = 6;
		Powerclips[ i ].h = 6;
	}

	for( int i = 0; i < 45; i++ )
	{
		CrossesClips[ i ].x = ( i % 9 ) * 44;
		CrossesClips[ i ].y = ( i / 9 ) * 44;
		CrossesClips[ i ].w = 44;
		CrossesClips[ i ].h = 44;
	}

	for( int i = 0; i < 6; i++ )
	{
		if( i < 3 )
		{
			GlowClips[ i ].x = 0;
			GlowClips[ i ].y = i * 42;
			GlowClips[ i ].w = 42;
			GlowClips[ i ].h = 42;
		}
		else
		{
			GlowClips[ i ].x = 42;
			GlowClips[ i ].y = (i-3) * 45;
			GlowClips[ i ].w = 42;
			GlowClips[ i ].h = 45;
		}
	}

	//avatar
	//running
	for( int i = 0; i < 16; i++ )
	{
		running[ i ].x = ( i % 8 ) * 32;
		if( i < 8 ) running[ i ].y = 0; else running[ i ].y = 40;
		running[ i ].w = 32;
		running[ i ].h = 40;
	}

	//accelerating
	//you need to take away five less from x and 8 less from y
	for( int i = 0; i < 48; i++ )
	{
		accelerating[ i ].x = ( i % 24 ) * 22;
		if( i < 24 ) accelerating[ i ].y = 0; else accelerating[ i ].y = 32;
		accelerating[ i ].w = 22;
		accelerating[ i ].h = 32;
	}

	for( int i = 0; i < 16; i++ )
	{
		climbing[ i ].x = i * 32;
		climbing[ i ].y = 0;
		climbing[ i ].w = 32;
		climbing[ i ].h = 32;
	}

	for( int i = 0; i < 10; i++ )
	{
		for( int j = 0; j < 3; j++ )
		{
			throwing[ 3*i+j ].x = j * 36;
			throwing[ 3*i+j ].y = 42 * i;
			throwing[ 3*i+j ].w = 36;
			throwing[ 3*i+j ].h = 42;
		}
	}

	for( int i = 0; i < 16; i++ )
	{
		standing[ i ].x = 16 * i;
		standing[ i ].y = 0;
		standing[ i ].w = 16;
		standing[ i ].h = 32;

		standing[ i + 16 ].x = 16 * i;
		standing[ i + 16 ].y = 32;
		standing[ i + 16 ].w = 16;
		standing[ i + 16 ].h = 32;
	}

	for( int i = 0; i < 6; i++ )
	{
		BeadClips[ i ].x = 0;
		BeadClips[ i ].y = i * 6;
		BeadClips[ i ].w = 6;
		BeadClips[ i ].h = 6;
	}

	for( int i = 0; i < 16; i++ )
	{
		climbingswinging[ i ].x = 22 * i;
		climbingswinging[ i ].y = 0;
		climbingswinging[ i ].w = 22;
		climbingswinging[ i ].h = 24;
	}

	for( int i = 0; i < 13; i++ )
	{
		vanishclips[ i ].x = i * 70;
		vanishclips[ i ].y = 0;
		vanishclips[ i ].h = 47;
		vanishclips[ i ].w = 70;
	}	

	for( int i = 0; i < 73; i++ )
	{
		featherclips[ i ].x = 0;
		featherclips[ i ].y = i * 35;
		featherclips[ i ].h = 35;
		featherclips[ i ].w = 35;
	}

	for( int i = 73; i < 12 + 73; i++ )
	{
		featherclips[ i ].x = 36;
		featherclips[ i ].y = (i-73) * 30;
		featherclips[ i ].h = 30;
		featherclips[ i ].w = 30;
	}

	for( int i = 12 + 73; i < 12 + 17 + 73; i++ )
	{
		featherclips[ i ].x = 67;
		featherclips[ i ].y = (i-(12 + 73)) * 20;
		featherclips[ i ].h = 20;
		featherclips[ i ].w = 20;
	}

	for( int i = 12 + 17 + 73; i < 73 + 12 + 17 + 60; i++ )
	{
		featherclips[ i ].x = 89;
		featherclips[ i ].y = (i-(12 + 17 + 73)) * 27;
		featherclips[ i ].h = 27;
		featherclips[ i ].w = 27;
	}

	for( int i = 73 + 12 + 17 + 60; i < 45 + 73 + 12 + 17 + 60; i++ )
	{
		featherclips[ i ].x = 118;
		featherclips[ i ].y = (i-(73 + 12 + 17 + 60)) * 24;
		featherclips[ i ].h = 24;
		featherclips[ i ].w = 23;
	}

	for( int i = 0; i < 4; i++ )
	{
		floatingclips[ i ].x = i * 30;
		floatingclips[ i ].y = 0;
		floatingclips[ i ].w = 30;
		floatingclips[ i ].h = 28;
	}

	for( int i = 0; i < 8; i++ )
	{
		ControlKeyClips[ i ].x = 0;
		ControlKeyClips[ i ].y = i * 24;
		ControlKeyClips[ i ].w = 24;
		ControlKeyClips[ i ].h = 24;
	}

	for( int i = 0; i < 6; i++ )
	{
		flyingdownclips[ i ].x = i * 30;
		flyingdownclips[ i ].y = 1;
		flyingdownclips[ i ].h = 28;
		flyingdownclips[ i ].w = 28;
	}

	for( int i = 0; i < 6; i++ )
	{
		flyingdownleftclips[ i ].x = i * 30;
		flyingdownleftclips[ i ].y = 30 + 1;
		flyingdownleftclips[ i ].h = 28;
		flyingdownleftclips[ i ].w = 28;
	}

	for( int i = 0; i < 6; i++ )
	{
		flyingleftclips[ i ].x = i * 30 + 1;
		flyingleftclips[ i ].y = 30 * 2 + 1;
		flyingleftclips[ i ].h = 28;
		flyingleftclips[ i ].w = 28;
	}

	for( int i = 0; i < 6; i++ )
	{
		flyingupleftclips[ i ].x = i * 30 + 1;
		flyingupleftclips[ i ].y = 30 * 3;
		flyingupleftclips[ i ].h = 28;
		flyingupleftclips[ i ].w = 28;
	}

	for( int i = 0; i < 6; i++ )
	{
		flyingupclips[ i ].x = i * 30;
		flyingupclips[ i ].y = 30 * 4 + 1;
		flyingupclips[ i ].h = 28;
		flyingupclips[ i ].w = 28;
	}

	for( int i = 0; i < 6; i++ )
	{
		flyinguprightclips[ i ].x = i * 30 + 1;
		flyinguprightclips[ i ].y = 30 * 5;
		flyinguprightclips[ i ].h = 28;
		flyinguprightclips[ i ].w = 28;
	}

	for( int i = 0; i < 6; i++ )
	{
		flyingrightclips[ i ].x = i * 30;
		flyingrightclips[ i ].y = 30 * 6 + 1;
		flyingrightclips[ i ].h = 28;
		flyingrightclips[ i ].w = 28;
	}

	for( int i = 0; i < 6; i++ )
	{
		flyingdownrightclips[ i ].x = i * 30 + 2;
		flyingdownrightclips[ i ].y = 30 * 7 + 1;
		flyingdownrightclips[ i ].h = 28;
		flyingdownrightclips[ i ].w = 28;
	}
}

void drawline( int x, int y, int portion )
{
	//make it so avatar doesn't twirl
	NoBeadOverride = 1;

	//point we're aiming for.
	int z = camera.x + SCREEN_WIDTH / 2 + 1;
	int j = camera.y + SCREEN_HEIGHT / 2 + 1;

	//portion ranges from 0 to 6. It can be less if you like.
	if( portion == 7 ) return;

	//the oriented co ords of each end of the line
	int y1, y2, x1, x2;

	//we want this to start low, end low, and be high in the middle. simple solution: increase by an absolute amount every draw
	int alphalevel = 128;

	//We want x1, y1 at the top, which is different depending on whether the angel is above the point
	if( y > j )
	{
		//the angel is visually "below" the dot. So the dot gets the first things
		y1 = j;
		x1 = z;

		y2 = y;
		x2 = x;

		alphalevel = 250;
	}
	else
	{
		//this also happens if we have a straight horizontal line
		y1 = y;
		x1 = x;

		y2 = j;
		x2 = z;

		alphalevel = 5;
	}

	

	//this would make a great name for a band
	bool AlphaDescending = 0;

	//whether we ascend or descend with the pixel.
	bool AlphaDirection = 0;

	//which ones are problems? The lower half, with the left being fine.

	//draw the lucky line
	if( j > y )
	{
		for( int r = y+(j-y)/7*portion; r <= y+(j-y)/7*(portion+1); r++ )
		{

			int topcross, bottomcross, leftbound, rightbound;

			//work out the range of the x values for this row
			topcross = ( r - y1 ) * ( x2 - x1 );
			bottomcross = ( r + 1 - y1 ) * ( x2 - x1 );

			//work out whether the line is going downward left or downward right.
			if( topcross > bottomcross )	{ leftbound = bottomcross; rightbound = topcross; }
			else							{ leftbound = topcross; rightbound = bottomcross; }

			//we start at x, y, always.
			//problem: if you're directly above, there is only one pixel "horizontally", therefore everything gets drawn
			if( x2 < x1 ) //below, to the left, or above, to the right
			{
				if( y > j )
				{
					for( int s = x2+(x1-x2)/7*portion; s <= x2+(x1-x2)/7*(portion+1); s++ )	
					{
						//if we've passed the part with the line, we're done with this row
						if( rightbound < ( s - x1 ) * ( y2 - y1 ) ) break;

						//if we're before the part with the line
						if( ( s + 1 - x1 ) * ( y2 - y1 ) < leftbound ) continue;

						if( !white ) SDL_SetAlpha( laser, SDL_SRCALPHA, alphalevel );
						else SDL_SetAlpha( laser2, SDL_SRCALPHA, alphalevel );

						if( alphalevel < 250 ) alphalevel += 6;
						if( s == x1+(x2-x1)/7*(portion+1) - 1 ) alphalevel = 250;

						if( !white ) apply_surface( s - camera.x, r - camera.y, laser, screen );
						else apply_surface( s - camera.x, r - camera.y, laser2, screen );
					}
				}
				else
				{
					for( int s = x2+(x1-x2)/7*(7-portion-1); s <= x2+(x1-x2)/7*(7-portion); s++ )	
					{
						//if we've passed the part with the line, we're done with this row
						if( rightbound < ( s - x1 ) * ( y2 - y1 ) ) break;

						//if we're before the part with the line
						if( ( s + 1 - x1 ) * ( y2 - y1 ) < leftbound ) continue;

						if( !white ) SDL_SetAlpha( laser, SDL_SRCALPHA, alphalevel );
						else SDL_SetAlpha( laser2, SDL_SRCALPHA, alphalevel );

						if( alphalevel < 250 ) alphalevel += 6;
						if( s == x1+(x2-x1)/7*(7-portion) - 1 ) alphalevel = 250;

						if( !white ) apply_surface( s - camera.x, r - camera.y, laser, screen );
						else apply_surface( s - camera.x, r - camera.y, laser2, screen );
					}
				}
			}
			else
			{
				if( y < j )
				{
					for( int s = x1+(x2-x1)/7*portion; s <= x1+(x2-x1)/7*(portion+1); s++ )
					{
						if( rightbound < ( s - x1 ) * ( y2 - y1 ) ) break;

						if( ( s + 1 - x1 ) * ( y2 - y1 ) < leftbound ) continue;

						if( !white ) SDL_SetAlpha( laser, SDL_SRCALPHA, alphalevel );
						else SDL_SetAlpha( laser2, SDL_SRCALPHA, alphalevel );

						if( alphalevel < 250 ) alphalevel += 6;
						if( s == x1+(x2-x1)/7*(portion+1) - 1 ) alphalevel = 250;

						if( !white ) apply_surface( s - camera.x, r - camera.y, laser, screen );
						else apply_surface( s - camera.x, r - camera.y, laser2, screen );
					}
				}
				else
				{
					for( int s = x1+(x2-x1)/7*(7-portion-1); s <= x1+(x2-x1)/7*(7-portion); s++ )
					{
						if( rightbound < ( s - x1 ) * ( y2 - y1 ) ) break;

						if( ( s + 1 - x1 ) * ( y2 - y1 ) < leftbound ) continue;

						if( !white ) SDL_SetAlpha( laser, SDL_SRCALPHA, alphalevel );
						else SDL_SetAlpha( laser2, SDL_SRCALPHA, alphalevel );

						if( alphalevel < 250 ) alphalevel += 6;
						if( s == x1+(x2-x1)/7*(7-portion) - 1 ) alphalevel = 250;

						if( !white ) apply_surface( s - camera.x, r - camera.y, laser, screen );
						else apply_surface( s - camera.x, r - camera.y, laser2, screen );
					}
				}
			}
		}
	}
	else
	{
		for( int r = j+(y-j)/7*(7-portion-1); r <= j+(y-j)/7*(7-portion); r++ )
		{
			int topcross, bottomcross, leftbound, rightbound;

			//work out the range of the x values for this row
			topcross = ( r - y1 ) * ( x2 - x1 );
			bottomcross = ( r + 1 - y1 ) * ( x2 - x1 );

			//work out whether the line is going downward left or downward right.
			if( topcross > bottomcross )	{ leftbound = bottomcross; rightbound = topcross; }
			else							{ leftbound = topcross; rightbound = bottomcross; }

			//we start at x, y, always.
			//problem: if you're directly above, there is only one pixel "horizontally", therefore everything gets drawn
			if( x2 < x1 ) //below, to the left, or above, to the right
			{
				if( y > j )
				{
					for( int s = x2+(x1-x2)/8*portion; s <= x2+(x1-x2)/7*(portion+1); s++ )	
					{
						//if we've passed the part with the line, we're done with this row
						if( rightbound < ( s - x1 ) * ( y2 - y1 ) ) break;

						//if we're before the part with the line
						if( ( s + 1 - x1 ) * ( y2 - y1 ) < leftbound ) continue;

						if( !white ) SDL_SetAlpha( laser, SDL_SRCALPHA, alphalevel );
						else SDL_SetAlpha( laser2, SDL_SRCALPHA, alphalevel );

						if( alphalevel > 6 ) alphalevel -= 6;

						if( !white ) apply_surface( s - camera.x, r - camera.y, laser, screen );
						else apply_surface( s - camera.x, r - camera.y, laser2, screen );
					}
				}
				else
				{
					for( int s = x2+(x1-x2)/7*(7-portion-1); s <= x2+(x1-x2)/7*(7-portion); s++ )	
					{
						//if we've passed the part with the line, we're done with this row
						if( rightbound < ( s - x1 ) * ( y2 - y1 ) ) break;

						//if we're before the part with the line
						if( ( s + 1 - x1 ) * ( y2 - y1 ) < leftbound ) continue;

						if( !white ) SDL_SetAlpha( laser, SDL_SRCALPHA, alphalevel );
						else SDL_SetAlpha( laser2, SDL_SRCALPHA, alphalevel );

						if( alphalevel >= 6 ) alphalevel -= 6;

						if( !white ) apply_surface( s - camera.x, r - camera.y, laser, screen );
						else apply_surface( s - camera.x, r - camera.y, laser2, screen );
					}
				}
			}
			else
			{
				if( y < j )
				{
					for( int s = x1+(x2-x1)/7*portion; s <= x1+(x2-x1)/7*(portion+1); s++ )
					{
						if( rightbound < ( s - x1 ) * ( y2 - y1 ) ) break;

						if( ( s + 1 - x1 ) * ( y2 - y1 ) < leftbound ) continue;

						if( !white ) SDL_SetAlpha( laser, SDL_SRCALPHA, alphalevel );
						else SDL_SetAlpha( laser2, SDL_SRCALPHA, alphalevel );

						if( alphalevel >= 6 ) alphalevel -= 6;

						if( !white ) apply_surface( s - camera.x, r - camera.y, laser, screen );
						else apply_surface( s - camera.x, r - camera.y, laser2, screen );
					}
				}
				else
				{
					for( int s = x1+(x2-x1)/7*(7-portion-1); s <= x1+(x2-x1)/7*(7-portion); s++ )
					{
						if( rightbound < ( s - x1 ) * ( y2 - y1 ) ) break;

						if( ( s + 1 - x1 ) * ( y2 - y1 ) < leftbound ) continue;

						if( !white ) SDL_SetAlpha( laser, SDL_SRCALPHA, alphalevel );
						else SDL_SetAlpha( laser2, SDL_SRCALPHA, alphalevel );

						if( alphalevel >= 6 ) alphalevel -= 6;

						if( !white ) apply_surface( s - camera.x, r - camera.y, laser, screen );
						else apply_surface( s - camera.x, r - camera.y, laser2, screen );
					}
				}
			}
		}
	}

	//problem: what if co ords are identical? Also change alpha, maybe change laser.
}

//constructor
particle::particle( int ecks, int whyy, int tiep, int dyrr )
{
	frame = 0;
	type = tiep;
	x = ecks;
	y = whyy;
	dir = dyrr;
}

//this gets called when we want a particle somewhere
void particle::relocate( int ecks, int whyy, int dyrr, bool end, int finishingEcks = 0, int finishingWhyy = 0 )
{
	if( type != 6 )
	{
		frame = 0;
		x = ecks;
		y = whyy;
		dir = dyrr;

		final = end;
	}
	else
	{
		frame = 0;

		dir = rand();
		while( dir == 8 ) dir = rand();

		frame = 0;

		x = camera.x + rand() % SCREEN_WIDTH;
		y = camera.y + rand() % SCREEN_HEIGHT;

		while( y == camera.y ) y += rand() % SCREEN_HEIGHT;
	}
}

void particle::show( particle *restartparticle ) //these go below the wood
{
	//not being used
	if( dir == 8 ) return;

	if( type == 10 ) //gargpuff
	{
		//falling
		y += 1;

		SDL_SetAlpha( beadpic, SDL_SRCALPHA, 187 - (frame+1) * 17 );
		apply_surface( x - camera.x - 3, y - camera.y - 3, beadpic, screen, &BeadClips[ frame/2 + 1 ] ); //frame = 9 is last one

		SDL_SetAlpha( beadpic, SDL_SRCALPHA, 255 );
	}
	if( type == 9 ) //trail
	{
		if( dir == 0 ) { y += 1; } //and then maybe die if you hit a solid block?
		if( dir == 1 ) { y += 1; x += -1; }
		if( dir == 2 ) { x += -1; }
		if( dir == 3 ) { y += -1; x += -1; }
		if( dir == 4 ) { y += -1; }
		if( dir == 5 ) { y += -1; x += 1; }
		if( dir == 6 ) { x += 1; }
		if( dir == 7 ) { y += 1; x += 1; }

		SDL_SetAlpha( beadpic, SDL_SRCALPHA, 187 - (frame+1) * 17 );
		apply_surface( x - camera.x - 3, y - camera.y - 3, beadpic, screen, &BeadClips[ frame/2 + 1 ] ); //frame = 9 is last one

		SDL_SetAlpha( beadpic, SDL_SRCALPHA, 255 );
	}
	if( type == 6 )
	{
		//feathers

		//if you can't be seen, relocate
		if(    y > camera.y + camera.h + 10
			|| y < camera.y - 30
			|| x > camera.x + camera.w + 10
			|| x < camera.x - 30 )
		{
			//worried about the player forgetting which one is the bullet? It does travel faster. Glow?
			//put them all one one sheet, and maybe some smaller versions too.
			

			//if you hit the top, player was going down and might see stuff appear in the area they're going into
			if( y < camera.y - 30 ) { y = camera.y + SCREEN_HEIGHT - 1; x = camera.x + rand() % SCREEN_WIDTH; }
			//if hit bottom, player's either going up or standing still.
			if( y > camera.y + camera.h + 10 ) { y = camera.y - 30; x = camera.x + rand() % SCREEN_WIDTH; }
			//if hit sides, you might appear halfway down other sides
			if( x > camera.x + camera.w + 10 ) { y = camera.y - 10 + rand() % SCREEN_HEIGHT; x = camera.x - 30; }
			if( x < camera.x - 30 ) { y = camera.y - 30 + rand() % SCREEN_HEIGHT; x = camera.x + SCREEN_WIDTH -1; }
			
			dir = rand();
			while( dir == 8 ) dir = rand();

			frame = 0;
		}

		//move. Dir
		y += dir % 3 + 1;

		SDL_SetAlpha( feather, SDL_SRCALPHA, 70 + dir % 25 );

		//the animations have different lengths and you want them to go at different speeds.
		//there are 73 bow frames, 12 dec frames, 17 pent frames, 60 hex frames, 45 rhomb frames 
		//you could involve "level" here to get nice variations
		if( dir % 2 )
		{
			if( dir % 5 == 0 ) apply_surface( x - camera.x, y - camera.y, feather, screen, &featherclips[ ((frame*(dir % 2 + 1 )) % 73) ] );
			if( dir % 5 == 1 ) apply_surface( x - camera.x, y - camera.y, feather, screen, &featherclips[ ((frame*(dir % 2 + 1 )) % 12) + 73 ] );
			if( dir % 5 == 2 ) apply_surface( x - camera.x, y - camera.y, feather, screen, &featherclips[ ((frame*(dir % 2 + 1 )) % 17) + 73 + 12 ] );
			if( dir % 5 == 3 ) apply_surface( x - camera.x, y - camera.y, feather, screen, &featherclips[ ((frame*(dir % 2 + 1 )) % 60) + 73 + 12 + 17 ] );
			if( dir % 5 == 4 ) apply_surface( x - camera.x, y - camera.y, feather, screen, &featherclips[ ((frame*(dir % 2 + 1 )) % 45) + 73 + 12 + 17 + 60 ] );
		}
		else
		{
			if( dir % 5 == 0 ) apply_surface( x - camera.x, y - camera.y, feather, screen, &featherclips[ 72-((frame*(dir % 2 + 1 )) % 73) ] );
			if( dir % 5 == 1 ) apply_surface( x - camera.x, y - camera.y, feather, screen, &featherclips[ 11-((frame*(dir % 2 + 1 )) % 12) + 73 ] );
			if( dir % 5 == 2 ) apply_surface( x - camera.x, y - camera.y, feather, screen, &featherclips[ 16-((frame*(dir % 2 + 1 )) % 17) + 73 + 12 ] );
			if( dir % 5 == 3 ) apply_surface( x - camera.x, y - camera.y, feather, screen, &featherclips[ 59-((frame*(dir % 2 + 1 )) % 60) + 73 + 12 + 17 ] );
			if( dir % 5 == 4 ) apply_surface( x - camera.x, y - camera.y, feather, screen, &featherclips[ 44-((frame*(dir % 2 + 1 )) % 45) + 73 + 12 + 17 + 60 ] );
		}
	}
	else
	if( type == 0 ) //angel
	{
		apply_surface( x - camera.x - 5, y - camera.y, angelrelease, screen, &vanishclips[ frame ] );
		apply_surface( x - camera.x - 5, y - camera.y, angelrelease, wall, &vanishclips[ frame ] );
	}
	else
	if( type == 1 )
	{
		//and then move
		//Do you want it to collide with wood?
		if( dir == 0 ) { y += 4; } //and then maybe die if you hit a solid block?
		if( dir == 1 ) { y += 4; x += -4; }
		if( dir == 2 ) { x += -4; }
		if( dir == 3 ) { y += -4; x += -4; }
		if( dir == 4 ) { y += -4; }
		if( dir == 5 ) { y += -4; x += 4; }
		if( dir == 6 ) { x += 4; }
		if( dir == 7 ) { y += 4; x += 4; }

		//draw the picture
		//maybe half the alpha each time?
		SDL_SetAlpha( smoke, SDL_SRCALPHA, 255 - frame * 30 );
		apply_surface( x - camera.x - 4, y - camera.y - 4, smoke, screen, &puffclips[ frame ] );

		//zoom back to player  
		drawline( x, y, frame );
	}
	else
	if( type == 2 ) //spark
	{
		//same thing, consistent place
		SDL_SetAlpha( smoke, SDL_SRCALPHA, 255 - frame * 30 );
		apply_surface( x - camera.x - 4, y - camera.y - 4, smoke, screen, &puffclips[ frame ] );
	}
	else
	if( type == 3 ) //restart button 
	{
		//huge delay if you're on the level with two angels below
		if( level == 18 )
		{
			if( frame >= 600 )
			{
				if( (frame-600) < 8 )SDL_SetAlpha( keyUP, SDL_SRCALPHA, (frame-600) * 32 );
				else( keyUP, SDL_SRCALPHA, 255 );

				if( (frame-600) < 8 ) apply_surface( x - camera.x, y - camera.y, keyUP, wall, &ControlKeyClips[ 7 - (frame-600) ] );
				else apply_surface( x - camera.x, y - camera.y, keyUP, wall, &ControlKeyClips[ 0 ] );
			}
		}
		else
		{
			if( frame < 8 )SDL_SetAlpha( keyUP, SDL_SRCALPHA, frame * 32 );
			else( keyUP, SDL_SRCALPHA, 255 );

			if( frame < 8 ) apply_surface( x - camera.x, y - camera.y, keyUP, wall, &ControlKeyClips[ 7 - frame ] );
			else apply_surface( x - camera.x, y - camera.y, keyUP, wall, &ControlKeyClips[ 0 ] );
		}
	}
	else

	//final particle, very complex
	if( type == 4 )
	{
		//while you exist, player does not really shoot. Though maybe if they shoot at the precise time you loopify... well, that's pretty improbable.
		pressedQ = 0;
		pressedW = 0;
		pressedE = 0;
		pressedA = 0;
		pressedD = 0;
		pressedC = 0;
		pressedW = 0;
		pressedX = 0;

		//if you need to go downright to get around the blocks
		if( frame < 20 )
		{
			x += 4;
			y += 4;	

			apply_surface( x - camera.x, y - camera.y, moving, wall, &flyingdownrightclips[ ( frame % 24 ) / 4 ]  );
		}
		else
		//then up
		if( frame >= 20 && frame < 37 )
		{
			y -= 4;

			apply_surface( x - camera.x, y - camera.y, moving, wall, &flyingupclips[ ( frame % 24 ) / 4 ]  );

			if( y < camera.y + 136 )
			{
				//avatar's surprised to see you
				script = 1;
			}
		}
		//then along
		else
		if( frame >= 37 && x > camera.x + 200 )
		{
			y = camera.y + 104;
			x -= 4;
		
			//if you're close to the avatar, put the right frame in place, and then that's it for this section.
			if( x == camera.x + 200 || x == camera.x + 204 || x == camera.x + 208 || x == camera.x + 212 )
			{
				//last thing before we pass over
				if( x == camera.x + 200 )
				{
					//it's up to the avatar at this point. Though jeez, it seems the avatar is showing his one with the angel in the same frame.
					script = 3;

					//play a nice sound. Stop the soundtrack.
					Mix_HaltChannel( 0 );
					Mix_PlayChannel( 1, la, 0 );
				}
				else
				//originally meant for avatar but we can only be sensetive here. Hmm, are we seeing shockedclips
				apply_surface( x - camera.x - 4, 112, avatarshocked, wall, &shockedclips[ 1 ] );
			}
			//if you're not close just fly along
			else apply_surface( x - camera.x, y - camera.y, moving, wall, &flyingleftclips[ ( frame % 24 ) / 4 ]  );
		}
		else
		//then wave
		if( frame > 130 )
		{
			//maybe script = 4? Don't exactly know what to do with this. We'd like avatar to look up but not move
			script = 1;

			//you may have drifted in the hug, set us in place once.
			if( frame == 131 ) {
				y = camera.y + 92;
				x = camera.x + 170;
			}
			
			//show us waving for a while
			if( frame <= 180 ) apply_surface( x - camera.x + 17, y - camera.y + 14, avatarshocked, wall, &shockedclips[ 4 + (frame / 4 ) % 4 ] );

			//this we do when we're done waving
			if( frame == 170 )
			{
				//turn into an angel
				type = 0;

				//and shake!
				shake = 12;

				//play the nice sound
				Mix_PlayChannel( 2, crotales, 0 );

				//change the avatar and allow him to move
				script = 4;

				//and we need the start of the animation
				frame = -1;
			}
		}
	}
	else
	//if you're a bit of a level... you're a great big pic with a curved acceleration gradient
	//it will be difficult working out where they start and end. Both of these need to be input, then we can interpolate between them here.
	//endingX and Y are difficult - position the "location" on the rectangle in an easily-understood place.
	if( type == 5 )
	{
		//if you're just beginning, play a grindy sound. NOT crotales
		if( frame == 0 ) Mix_PlayChannel( 3, crotales, 0 );

		//speed
		int speed = 0;

		//initially accelerate
		if( frame < 12 ) speed = frame / 3;
		//else
		
		//if you're close to the end you slow down
		//if( abs( finishingX - x ) < 3 || abs( finishingY - y ) < 3 ) speed = 1;
		//else
		//if( abs( finishingX - x ) < 9 || abs( finishingY - y ) < 9 ) speed = 2;
		//else
		//if( abs( finishingX - x ) < 18 || abs( finishingY - y ) < 18 ) speed = 3;
		//if you're neither beginning nor ending, full speed
		//else speed = 4;

		//if you're close to finishing, slow down somehow? well, you have to know finishingx anyway so you know when to stop

		//move, based on direction.
		if( dir == 0 ) { y += speed; } //and then maybe die if you hit a solid block?
		if( dir == 1 ) { y += speed; x += -speed; }
		if( dir == 2 ) { x += -speed; }
		if( dir == 3 ) { y += -speed; x += -speed; }
		if( dir == 4 ) { y += -speed; }
		if( dir == 5 ) { y += -speed; x += speed; }
		if( dir == 6 ) { x += speed; }
		if( dir == 7 ) { y += speed; x += speed; }

		//if it's done it's done
		//if( x == finishingX && y == finishingY ) { dir = 8; return; }

		//make it appear on the screen if it's not done
		apply_surface( x - camera.x, y - camera.y, moving, wall, &flyingleftclips[ ( frame % 24 ) / 4 ]  );
	}

	//frame’s done
	frame++;

	//was that the last frame? if so we can destroy. And if it's a final angel, we move forward.
	if( (type == 9 || type == 10 ) && frame == 11 ) dir = 8;
	if( type == 0 && frame == 7 && final ) { advance = 1; dir = 8; frame = 0; }
	if( type == 1 && frame == 7 ) { dir = 8; NoBeadOverride = 0; }
	if( type == 2 && frame == 7 ) dir = 8;

	//angel release
	if( type == 0 && frame == 13 )
	{
		//important thing first
		dir = 8;

		//restart levels
		if( level == 18 || level == 20 )
		{
			if( level == 18 && !hadprompt18 )
			{
				restartparticle->relocate( 228, 107, 0, 0 );
				hadprompt18 = 1;
			}

			if( level == 20 && !hadprompt19 && ( !hadprompt18 || !hadprompt13 ) )
			{
				restartparticle->relocate( 38, 116, 0, 0 );
				hadprompt19 = 1;
			}
		}		
	}
}
Tile::Tile( int x, int y, int tileType, bool antiladder )
{
    //Get the offsets
    box.x = x;
    box.y = y;

    //Set the collision box
    box.w = TILE_WIDTH;
    box.h = TILE_HEIGHT;

    //Get the tile type
    type = tileType;

	//if it's a block, randomize the texture
	randomer = rand() % 4;

	//set_tiles works out if it's a ladder and has passed us 1 if so. If it's not a floor tile, it's 0 anyway.
	floor = antiladder;

	//this can only be changed by a tile near it being glass
	cream = 0;
}

void Tile::show( bool lead, bool donecreaming )
{
	if( type == TILE_GLASS ) return;

	//we have to show the noncream last and the lead first
	if( donecreaming )
	{
		//this tile is octagonal, it's there to smooth things out
		if( !cream ) apply_surface( box.x - camera.x - 4, box.y - camera.y - 4, tileSheet, screen, &clips[ TILE_GLASS ] ); 
		return;
	}
	else


    //If the tile is on screen
    if( check_collision( camera, box ) == true || type == TILE_FLOOR )
    {
		//make sure floor tiles are only visible if they're a ladder
		if( floor )
		{
			//you don't want it showing a ladder; you don't want it showing anything at all even though it is there.
			return;
		}
		else
		if( type == TILE_FLOOR ) //if it's a ladder
		{
			apply_surface( box.x - camera.x, box.y - camera.y - TILE_HEIGHT * 7, tileSheet, screen, &clips[ type ] );
		}
		else
		if( type == 5 && !lead && randomer ) //if it's a block
		{
			//the texture we show depends on our random number
			apply_surface( box.x - camera.x, box.y - camera.y, tileSheet, screen, &clips[ 12 + randomer  ] );
		}
		else
        //Show the tile. If we're doing the lead undercoating, show the alt tiles.
        apply_surface( box.x - camera.x - lead, box.y - camera.y - lead, tileSheet, screen, &clips[ type + lead * 7 ] );
    }
}

int Tile::get_type()
{
    return type;
}

void Tile::make_cream()
{
	cream = 1;
}

SDL_Rect Tile::get_box()
{
    return box;
}

//Takes the avatar's middle and creates a bead there. The bead is moved to the avatar's edge.
Bead::Bead( int Ecks, int Whyy, int direction )
{
	x = Ecks;
	y = Whyy;

	dir = direction;

	TrailCycle = 1;

	if( dir == 0 ) { y += 8; }
	else
	if( dir == 1 ) { x += -8; y += 8; }
	else
	if( dir == 2 ) { x += -8; }
	else
	if( dir == 3 ) { x += -8; y += -8; }
	else
	if( dir == 4 ) { y += -8; }
	else
	if( dir == 5 ) { x += 8; y += -8; }
	else
	if( dir == 6 ) { x += 8; }
	else
	if( dir == 7 ) { x += 8; y += 8; }
}

//this is the version sans particle
bool Bead::move( bool prediction, Tile *tiles[], stone *stones[], angel *angels[] )
{
	//we'll change it if we hit anything
	bool hitangel = 0;

	//if it's a null bead, don't bother
	if( dir == 8 ) return hitangel;

	//if you're out of alignment, FUCK. Maybe you should return 1?
	if( x % 4 != 0 || y % 4 != 0 ) return hitangel;

	int t = y / TILE_WIDTH * LEVEL_WIDTH / TILE_WIDTH + x / TILE_WIDTH;	

	//places you're going to put the tiles for analysis
	int squareA;
	int squareB;
	int squareC;
	int squareD;

	//If an angel is put in danger by this bullet, its number in the array will be stored here. There are two, as you can affect a maximum of 2 in one node
	int endangeredA = TOTAL_ANGELS;
	int endangeredB = TOTAL_ANGELS;

	//if the bullet is in a nook then in order to work out whether to kill the angel, we'll need to know at the same time the dir of the bullet and if whack is true.
	//if the bead enters a nook, the RESULTING direction required for a kill will be placed in this variable.
	int nookalertA = 8;
	int nookalertB = 8;

	//possible things the tiles can be
	int righthang;
	int lefthang;
	int leftwedge;
	int rightwedge;

	//abombinably hacky variable that will stall the bead for a frame to represent its having hit the centre of a diagonal surface
	bool primarystall = 0;
	bool secondarystall = 0;

	//variable that says whether or not a collision has occured; will tell us to play a sound.
	bool whack = 0;
	
	//these are the absolute boxes. they will be turned into relative boxes that depend upon the rotation (direction) of the bead.
	int bottomright = tiles[ t ]->get_type();
	int bottomleft = tiles[ t - 1 ]->get_type();
	int topright = tiles[ t - ( LEVEL_WIDTH / TILE_WIDTH ) ]->get_type();
	int topleft = tiles[ t - ( LEVEL_WIDTH / TILE_WIDTH ) - 1 ]->get_type();

	//if the stones are involved...
	for( int u = 0; u < TOTAL_STONES; u++)
	{
		//don't want an imaginary collision in top corner
		if( !stones[ u ]->get_on() ) continue;

		//stones move before beads, but it's nicer if we react to what was in the previous frame...
		int stoneX = stones[u]->get_x();
		int stoneY = stones[u]->get_y();

		//if a descending garg hits a sideways-going bullet, it should gain downward momentum. You should make a puzzle out of this (push)
		if( y == stoneY + 15 * TILE_HEIGHT / 2 && stoneX < x && x < stoneX + 8 * TILE_WIDTH ) //stone has moved onto the bead
		{			
			//if you were travelling left
			if( dir == 2 )
			{
				//we don't need to bother with the rest of the function

				//go down left
				dir = 1;

				x -= TILE_WIDTH;
				y += TILE_HEIGHT;
				
				//play the appropriate sound
				Mix_HaltChannel( 8 );
				Mix_PlayChannel( 8, glock_C, 0 );

				//I guess this means the avatar won't be harmed by a bead immediately after it hits a garg's bottom. Oh well.
				return hitangel; 
			}

			if( dir == 6 ) 
			{
				dir = 7;

				x += TILE_WIDTH;
				y += TILE_HEIGHT;
				
				Mix_HaltChannel( 14 );
				Mix_PlayChannel( 14, glock_I, 0 );
			
				return hitangel; 
			}
		}

		//whether we need to inflate the height of the stone. So by default we're in the middle
		int rounder = 0;

		//the problem is that if a bullet is travelling up to an innocent-looking bottom, it may be engulfed. Solving this breaks stones that are still
		//it's ok to get embedded in the two pixels above the stone. The stone will move down anyway. You get an uncomfy frame though.
		

		

		//either the stone is falling in which case it should be treated as being ahead of itself to avoid embedding, or it is carried, so it's not moving
		if( stoneY % 4 == 0 )
		{
			//if the stone's falling we must add to the height
			if( stones[ u ]->ismoving() ) rounder = TILE_HEIGHT / 2;
			else
			{
				//so the stone isn't going anywhere. We deduct from the height
				rounder = 0 - TILE_HEIGHT / 2;
			}
		}

		if( stoneX < x && x < (stoneX+32) ) //middle
		{
			if( y == stoneY || y == stoneY - 2 ) { bottomleft = TILE_BLOCK; bottomright = TILE_BLOCK; }
			else
			if( y == stoneY + rounder + 34 || y == stoneY + rounder + 30 ) { topleft = TILE_BLOCK; topright = TILE_BLOCK; }
		}
		else
		if( x == stoneX )					//left side
		{
			if( y == stoneY ) bottomright = TILE_BLOCK;
			else
			if( y == stoneY + rounder + 34 ) topright = TILE_BLOCK;
			else
			if( y > stoneY && y < stoneY + rounder + 34 ) { topright = TILE_BLOCK; bottomright = TILE_BLOCK; }
		}
		else
		if( x == (stoneX+8*TILE_WIDTH) )	//right side
		{
			if( y == stoneY ) bottomleft = TILE_BLOCK;
			else
			if( y == stoneY + rounder + 34 ) topleft = TILE_BLOCK;
			else
			if( stoneY < y && y < stoneY + rounder + 34 ) { bottomleft = TILE_BLOCK; topleft = TILE_BLOCK; }
		}
	}

	//if the angels are involved. In the unlikely event that this surrounds the bead entirely then kill the angel to avoid mishaps. Don't "push" this.
	//All this could be sped up a lot
	for( int u = 0; u < TOTAL_ANGELS; u++ )
	{
		//don't want an imaginary colision in top corner
		if( !angels[ u ]->get_on() ) continue;

		//if the bead is anywhere on the surface of the octagon
		//how about if two beads kill the same angel at the same time?
		if(    12 < x - angels[ u ]->get_x() && x - angels[ u ]->get_x() < 48 //if you're in the column
			&& 12 < y - angels[ u ]->get_y() && y - angels[ u ]->get_y() < 48 //and the row
			&& !( ( x - angels[ u ]->get_x() == 16 || x - angels[ u ]->get_x() == 44 ) && ( y - angels[ u ]->get_y() == 16 || y - angels[ u ]->get_y() == 44 ) ) //and you're not at the very corners
		   )
		{
			unsigned char sides = 0;

			//numbers ascend anti clockwise from the bottom
			//nondiag sides
			if( y - angels[ u ]->get_y() == 16 ) sides += 16;
			if( y - angels[ u ]->get_y() == 44 ) sides += 1;
			if( x - angels[ u ]->get_x() == 16 ) sides += 64;
			if( x - angels[ u ]->get_x() == 44 ) sides += 4;

			//diag sides
			if( y - angels[ u ]->get_y() + x - angels[ u ]->get_x() == 40 ) sides += 32;
			if( y - angels[ u ]->get_y() + x - angels[ u ]->get_x() == 80 ) sides += 2;
			if( y - angels[ u ]->get_y() == x - angels[ u ]->get_x() - 20 ) sides += 8;
			if( y - angels[ u ]->get_y() == x - angels[ u ]->get_x() + 20 ) sides += 128;

			//top left nook. These directions are wrong - what if you've just bounced?
			if( y - angels[ u ]->get_y() + x - angels[ u ]->get_x() == 36 )
			{
				//if the angel isn't next to a little slope that gets in the way of its edge, then the angel's in vicinity
				if( bottomright != TILE_LEFTHANG ) bottomright = TILE_RIGHTWEDGE;
				sides = 0;

				//endanger this angel and set nook alert to the dir that a bounce on this part of the angel would cause.
				if( endangeredA == TOTAL_ANGELS )	{ endangeredA = u; nookalertA = 3; }
				else								{ endangeredB = u; nookalertB = 3; }
			}
			//bottom right nook
			if( y - angels[ u ]->get_y() + x - angels[ u ]->get_x() == 84 )
			{
				if( topleft != TILE_RIGHTWEDGE ) topleft = TILE_LEFTHANG;
				sides = 0;

				if( endangeredA == TOTAL_ANGELS )	{ endangeredA = u; nookalertA = 7; }
				else								{ endangeredB = u; nookalertB = 7; }
			}
			//top right nook
			if( y - angels[ u ]->get_y() == x - angels[ u ]->get_x() - 24 )
			{
				if( bottomleft != TILE_RIGHTHANG ) bottomleft = TILE_LEFTWEDGE;
				sides = 0;

				if( endangeredA == TOTAL_ANGELS )	{ endangeredA = u; nookalertA = 5; }
				else								{ endangeredB = u; nookalertB = 5; }
			}
			//bottom left nook
			if( y - angels[ u ]->get_y() == x - angels[ u ]->get_x() + 24 )
			{
				if( topright != TILE_LEFTWEDGE ) topright = TILE_RIGHTHANG;
				sides = 0;

				if( endangeredA == TOTAL_ANGELS )	{ endangeredA = u; nookalertA = 1; }
				else 								{ endangeredB = u; nookalertB = 1; }
			}

			//if you stick a "maybe die" variable in here. If there's a whack, they definitely die unless it's a stalled bounce. The deadly stalled bounces are handled by

			//also anti clockwise from bottom, starting with flat bit.
			if( sides == 1   )
			{
				//angel u is in danger! If 1's unused, use it
				if( endangeredA == TOTAL_ANGELS ) endangeredA = u;
				else endangeredB = u;

				//and put the relevant things into the quadrants around the bullet				
				topright = TILE_BLOCK;
				topleft = TILE_BLOCK; 
			}

			if( sides == 3   )
			{
				if( endangeredA == TOTAL_ANGELS ) endangeredA = u;
				else endangeredB = u;

				topleft = TILE_BLOCK;
				if( topright == TILE_RIGHTWEDGE ) topright = TILE_BLOCK; 
				else topright = TILE_LEFTHANG;
			}

			if( sides == 2   )
			{
				if( endangeredA == TOTAL_ANGELS ) endangeredA = u;
				else endangeredB = u;

				topleft = TILE_BLOCK;
				if( topright == TILE_RIGHTWEDGE ) topright = TILE_BLOCK; 
				else topright = TILE_LEFTHANG;
				if( bottomleft == TILE_RIGHTWEDGE ) topright = TILE_BLOCK; 
				else bottomleft = TILE_LEFTHANG;
			}

			if( sides == 6   )
			{
				if( endangeredA == TOTAL_ANGELS ) endangeredA = u;
				else endangeredB = u;

				topleft = TILE_BLOCK;
				if( bottomleft == TILE_RIGHTWEDGE ) bottomleft = TILE_BLOCK;
				else bottomleft = TILE_LEFTHANG; 
			}

			if( sides == 4   )
			{
				if( endangeredA == TOTAL_ANGELS ) endangeredA = u;
				else endangeredB = u;

				bottomleft = TILE_BLOCK;
				topleft = TILE_BLOCK; 
			}

			if( sides == 12  )
			{
				if( endangeredA == TOTAL_ANGELS ) endangeredA = u;
				else endangeredB = u;

				bottomleft = TILE_BLOCK;
				if( topleft == TILE_RIGHTHANG ) topleft = TILE_BLOCK;
				else topleft = TILE_LEFTWEDGE; 
			}

			if( sides == 8   )
			{
				if( endangeredA == TOTAL_ANGELS ) endangeredA = u;
				else endangeredB = u;

				bottomleft = TILE_BLOCK;
				if( topleft == TILE_RIGHTHANG ) topleft = TILE_BLOCK; 
				else topleft = TILE_LEFTWEDGE;
				if( bottomright == TILE_RIGHTHANG ) topleft = TILE_BLOCK; 
				else bottomright = TILE_LEFTWEDGE;
			}

			if( sides == 24  )
			{
				if( endangeredA == TOTAL_ANGELS ) endangeredA = u;
				else endangeredB = u;

				bottomleft = TILE_BLOCK;
				if( bottomright == TILE_RIGHTHANG ) bottomright = TILE_BLOCK;
				else bottomright = TILE_LEFTWEDGE;
			}

			if( sides == 16  ) 
			{
				if( endangeredA == TOTAL_ANGELS ) endangeredA = u;
				else endangeredB = u;

				bottomleft = TILE_BLOCK; 
				bottomright = TILE_BLOCK; 
			}

			if( sides == 48  ) 
			{
				if( endangeredA == TOTAL_ANGELS ) endangeredA = u;
				else endangeredB = u;

				bottomright = TILE_BLOCK;
				if( bottomleft == TILE_LEFTHANG ) bottomleft = TILE_BLOCK;
				else bottomleft = TILE_RIGHTWEDGE;
			}

			if( sides == 32  )
			{
				if( endangeredA == TOTAL_ANGELS ) endangeredA = u;
				else endangeredB = u;

				bottomright = TILE_BLOCK;
				if( bottomleft == TILE_LEFTHANG ) bottomleft = TILE_BLOCK; 
				else bottomleft = TILE_RIGHTWEDGE;
				if( topright == TILE_LEFTHANG ) topright = TILE_BLOCK; 
				else topright = TILE_RIGHTWEDGE;
			}

			if( sides == 96  )
			{
				if( endangeredA == TOTAL_ANGELS ) endangeredA = u;
				else endangeredB = u;

				bottomright = TILE_BLOCK;
				if( topright == TILE_LEFTHANG ) topright = TILE_BLOCK;
				else topright = TILE_RIGHTWEDGE;
			}

			if( sides == 64  ) 
			{
				if( endangeredA == TOTAL_ANGELS ) endangeredA = u;
				else endangeredB = u;

				bottomright = TILE_BLOCK;
				topright = TILE_BLOCK; 
			}

			if( sides == 192 )
			{
				if( endangeredA == TOTAL_ANGELS ) endangeredA = u;
				else endangeredB = u;

				topright = TILE_BLOCK;
				if( bottomright == TILE_LEFTWEDGE ) bottomright = TILE_BLOCK;
				else bottomright = TILE_RIGHTHANG;
			}

			if( sides == 128 )
			{
				if( endangeredA == TOTAL_ANGELS ) endangeredA = u;
				else endangeredB = u;

				topright = TILE_BLOCK;
				if( topleft == TILE_LEFTWEDGE ) topleft = TILE_BLOCK; 
				else topleft = TILE_RIGHTHANG;
				if( bottomright == TILE_LEFTWEDGE ) bottomright = TILE_BLOCK; 
				else bottomright = TILE_RIGHTHANG;
			}

			if( sides == 129 )
			{
				if( endangeredA == TOTAL_ANGELS ) endangeredA = u;
				else endangeredB = u;

				topright = TILE_BLOCK;
				if( topleft == TILE_LEFTWEDGE ) topleft = TILE_BLOCK;
				else topleft = TILE_RIGHTHANG;
			}

			//so the trapment thing. Are we only talking about "everything == TILE_BLOCK" or can you have a way in w/ no way out? W/ out the angel having "chased" it?
			if( topleft == TILE_BLOCK && topright == TILE_BLOCK && bottomleft == TILE_BLOCK && bottomright == TILE_BLOCK )
			{
				//MURDER THE ANGEL just in case
				hitangel = 1;

				//and then replace the blocks with what they were in the first place. This may get something strange, but it's all so unlikely.
				bottomright = tiles[ t ]->get_type();
				bottomleft = tiles[ t - 1 ]->get_type();
				topright = tiles[ t - ( LEVEL_WIDTH / TILE_WIDTH ) ]->get_type();
				topleft = tiles[ t - ( LEVEL_WIDTH / TILE_WIDTH ) - 1 ]->get_type();
			}
		}
	}

	//assign tile types and tile places, as they are changed by orientation
	//directly down or down-right
	if( dir == 0 || dir == 7 )
	{
		//As it is the top and left sides that are PART of the square, tiles[t] must be D
		squareD = bottomright;
		squareC = bottomleft;
		squareB = topright;
		squareA = topleft;

		lefthang = TILE_LEFTHANG;
		leftwedge = TILE_LEFTWEDGE;
		rightwedge = TILE_RIGHTWEDGE;
		righthang = TILE_RIGHTHANG;
	}
	else
	//to the left or down-left
	if( dir == 2 || dir == 1 )
	{
		squareB = bottomright;
		squareD = bottomleft;
		squareA = topright;
		squareC = topleft;

		lefthang = TILE_RIGHTHANG;
		leftwedge = TILE_LEFTHANG;
		rightwedge = TILE_LEFTWEDGE;
		righthang = TILE_RIGHTWEDGE;
	}
	else
	//up or up-left
	if( dir == 4 || dir == 3 )
	{
		squareA = bottomright;
		squareB = bottomleft;
		squareC = topright;
		squareD = topleft;

		lefthang = TILE_RIGHTWEDGE;
		leftwedge = TILE_RIGHTHANG;
		rightwedge = TILE_LEFTHANG;
		righthang = TILE_LEFTWEDGE;
	}
	else
	//right or up-right
	if( dir == 6 || dir == 5 )
	{
		squareC = bottomright;
		squareA = bottomleft;
		squareD = topright;
		squareB = topleft;

		lefthang = TILE_LEFTWEDGE;
		leftwedge = TILE_RIGHTWEDGE;
		rightwedge = TILE_RIGHTHANG;
		righthang = TILE_LEFTHANG;
	}

	//work out what way to bounce. Right now you are missing the fact that any diagonal rebound can go straight into a stall.

	//if we're nondiag. This treats it all as if the bullet's going down. Diagonal bounces 
	if( dir % 2 == 0 )
	{
		//go through every possible bloody combination
		if( squareC == rightwedge )
		{
			if( squareD == leftwedge )									{ dir += 4; whack = 1; }
			else
			if( squareD == lefthang || squareD == TILE_BLOCK ) //there's a surface
			{
				if( squareB == rightwedge )								{ dir += 2; whack = 1; }
				else
				if( squareB == TILE_BLOCK || squareB == leftwedge )		{ dir += 1; whack = 1; }
				else	//nowt at squareB
				{
					if( squareA == TILE_BLOCK )							{ dir += 4; whack = 1; } //very special case.
					else
					if( squareA == lefthang )							{ dir += 7; whack = 1; secondarystall = 1; }
					else												{ dir += 3; whack = 1; }
				}
			}
			//else Vel needn't be changed (there's nothing on the right)
		}
		else
		if( squareC == righthang || squareC == TILE_BLOCK ) //there's a surface
		{
			if( squareA == leftwedge )
			{
				if( squareD == leftwedge )								{ dir += 6; whack = 1; }
				else
				if( squareD == lefthang || squareD == TILE_BLOCK ) //there's a surface
				{
					if( squareB == rightwedge )							{ dir += 4; whack = 1; }
					else
					if( squareB == TILE_BLOCK || squareB == leftwedge )	{ dir += 3; whack = 1; }
					else
					if( squareB == righthang )							{ dir += 1; whack = 1; secondarystall = 1; }
					else												{ dir += 5; whack = 1; }
				}
				//else Vel needn't be changed (there's nothing on the right)
			}
			else
			if( squareA == TILE_BLOCK || squareA == rightwedge )
			{
				if( squareD == leftwedge )								{ dir += 7; whack = 1; }
				else
				if( squareD == lefthang || squareD == TILE_BLOCK ) //there's a surface
				{
					if( squareB == rightwedge )							{ dir += 5; whack = 1; }
					//else
					//if( squareB == block || squareB == leftwedge )	xVel = 		//it's impossible for the bead to be at this location
					else												{ dir += 6; whack = 1; }
				}
				//else Vel needn't be changed (there's nothing on the right)
			}
			else // there's a lefthang (special case), a righthang, or an incorporeal block at square A
			{
				if( squareD == leftwedge )
				{
					if( squareB == TILE_BLOCK )							{ dir += 4; whack = 1; } //very special case.
					else
					if( squareB == righthang )							{ dir += 1; whack = 1; secondarystall = 1; }
					else												{ dir += 5; whack = 1; }
				}
				else
				if( squareD == lefthang || squareD == TILE_BLOCK ) //there's a surface
				{
					if( squareB == rightwedge && squareA == lefthang )	{ dir += 7; whack = 1; secondarystall = 1; }
					else
					if( squareB == rightwedge )							{ dir += 3; whack = 1; }
					else
					if( squareB == TILE_BLOCK || squareB == leftwedge )	{ dir += 2; whack = 1; }
					else												{ dir += 4; whack = 1; } //there's a righthang, a lefthang (well...) , or an incorporeal block at square B and A
				}
				//else Vel needn't be changed (there's nothing on the right)
			}
		}
	}
	//if we're diag. This treats dir = 7 as default
	else
	{
		if( squareD == TILE_BLOCK || squareD == lefthang )
		{
			if( squareB == TILE_BLOCK || squareB == leftwedge )
			{
				if( squareC == TILE_BLOCK || squareC == righthang )
				{
					if( squareA == leftwedge )							{ dir += 5; whack = 1; }
					else
					if( squareA == righthang )							{ dir += 3; whack = 1; }
					else												{ dir += 4; whack = 1; }	//ain't nothing there, except for impossible things.
				}
				else
				if( squareC == rightwedge )
				{
					if( squareA == righthang )							{ dir += 2; whack = 1; }
					else												{ dir += 3; whack = 1; }	//ain't nothing there, except for inconsequential things.
				}
				else
				if( squareC == leftwedge )								
				{
					if( squareA == righthang )							{ dir += 1; whack = 1; }
					else												{ dir += 6; whack = 1; secondarystall = 1; }
				}
				else //there's nothing at squareC
				{
					if( squareA == righthang )							{ dir += 1; whack = 1; }
					else												{ dir += 2; whack = 1; }
				}
			}	
			else
			if( squareB == rightwedge )
			{
				if( squareC == TILE_BLOCK || squareC == righthang )
				{
					if( squareA == leftwedge )							{ dir += 6; whack = 1; }
					else												{ dir += 5; whack = 1; }
				}
				else
				if( squareC == rightwedge && squareA == lefthang )		{			whack = 1; secondarystall = 1; } //interesting!
				else
				if( squareC == rightwedge )								{ dir += 4; whack = 1; }
				else
				if( squareC == lefthang && squareA == leftwedge )		{ dir += 4; whack = 1; }
				else													{ dir += 3; whack = 1; } //there's nothing at squareC
			}
			else //squareB is empty or contains a righthang
			{
				if( squareC == TILE_BLOCK || squareC == righthang )
				{
					if( squareA == leftwedge )							{ dir += 7; whack = 1; }
					else												
					if( squareB == righthang )							{ dir += 2; whack = 1; secondarystall = 1; }
					else												{ dir += 6; whack = 1; }
				}
				else
				if( squareC == rightwedge )								{ dir += 5; whack = 1; }
				else //squareC is empty
				if( squareA == lefthang )								{			whack = 1; secondarystall = 1; }
				else													{ dir += 4; whack = 1; }
			}
		}
		else
		if( squareD == rightwedge )										{ dir += 4; whack = 1; primarystall = 1; }
		//else there's a righthang, a leftwedge, or an incorporeal block; dir needn't change.
	}

	//keep dir sensible
	dir = dir % 8;

	//kill the angels. If there's been a non-stall collision
	if( whack )
	{
		//if the placeholders have been changed, then an angel was involved in the whack.
		//stalled bullets need a special check
		if( primarystall )
		{
			if( endangeredA != TOTAL_ANGELS && dir == nookalertA ) { hitangel = 1; }
			if( endangeredB != TOTAL_ANGELS && dir == nookalertB ) { hitangel = 1; }
		}
		else
		{
			//check nookalert to make sure we're not talking about an angel requiring a nooked bead
			if( endangeredA != TOTAL_ANGELS && nookalertA == 8 ) { hitangel = 1; }
			if( endangeredB != TOTAL_ANGELS && nookalertB == 8 ) { hitangel = 1; }
		}
	}

	//you know what these are
	int xVel, yVel;

	//interpret dir
	if( dir == 0 )
	{
		xVel = 0;
		yVel = 4;
		
		if( !prediction && whack )
		{
			//This is a little screwed up because we want a simple octagonal level
			Mix_HaltChannel( 14 );
			Mix_PlayChannel( 14, glock_I, 0 );
		}
	}
	else
	if( dir == 1 )
	{
		xVel = -4;
		yVel = 4;
		if( !prediction && whack )
		{
			Mix_HaltChannel( 13 );
			Mix_PlayChannel( 13, glock_H, 0 );
		}
	}
	else
	if( dir == 2 )
	{
		xVel = -4;
		yVel = 0;
		if( !prediction && whack )
		{
			Mix_HaltChannel( 12 );
			Mix_PlayChannel( 12, glock_G, 0 );
		}
	}
	else
	if( dir == 3 )
	{
		xVel = -4;
		yVel = -4;
		if( !prediction && whack )
		{
			Mix_HaltChannel( 11 );
			Mix_PlayChannel( 11, glock_F, 0 );
		}
	}
	else
	if( dir == 4 )
	{
		xVel = 0;
		yVel = -4;
		if( !prediction && whack )
		{
			Mix_HaltChannel( 10 );
			Mix_PlayChannel( 10, glock_E, 0 );
		}
	}
	else
	if( dir == 5 )
	{
		xVel = 4;
		yVel = -4;
		if( !prediction && whack )
		{
			Mix_HaltChannel( 9 );
			Mix_PlayChannel( 9, glock_D, 0 );
		}
	}
	else
	if( dir == 6 )
	{
		xVel = 4;
		yVel = 0;
		if( !prediction && whack )
		{
			Mix_HaltChannel( 8 );
			Mix_PlayChannel( 8, glock_C, 0 );
		}
	}
	else
	if( dir == 7 )
	{
		xVel = 4;
		yVel = 4;
		if( !prediction && whack )
		{
			Mix_HaltChannel( 15 );
			Mix_PlayChannel( 15, glock_J, 0 ); 
		}
	}

	if( !primarystall && !secondarystall )
	{
		x += xVel;
		y += yVel;
	}

	//if it's hit the edges of a level, it should "go out into infinity".
	if( x == 0 || y == 0 || x == LEVEL_WIDTH || y == LEVEL_HEIGHT )
	{
		x = 0;
		y = 0;

		dir = 8;
		return hitangel;
	}
	
	//if you've not hit the avatar
	return hitangel;
}

//returns true if an angel was hit at any point
bool Bead::move( bool prediction, Tile *tiles[], stone *stones[], angel *angels[], particle *spark[], particle *release, int myposition, particle *trail[] )
{
	//we'll change it if we hit anything
	bool hitangel = 0;

	//if it's a null bead, don't bother
	if( dir == 8 ) return hitangel;

	//if you're out of alignment, FUCK. Maybe you should return 1?
	if( x % 4 != 0 || y % 4 != 0 ) return hitangel;

	int t = y / TILE_WIDTH * LEVEL_WIDTH / TILE_WIDTH + x / TILE_WIDTH;	

	//places you're going to put the tiles for analysis
	int squareA;
	int squareB;
	int squareC;
	int squareD;

	//If an angel is put in danger by this bullet, its number in the array will be stored here. There are two, as you can affect a maximum of 2 in one node
	int endangeredA = TOTAL_ANGELS;
	int endangeredB = TOTAL_ANGELS;

	//if the bullet is in a nook then in order to work out whether to kill the angel, we'll need to know at the same time the dir of the bullet and if whack is true.
	//if the bead enters a nook, the RESULTING direction required for a kill will be placed in this variable.
	int nookalertA = 8;
	int nookalertB = 8;

	//possible things the tiles can be
	int righthang;
	int lefthang;
	int leftwedge;
	int rightwedge;

	//abombinably hacky variable that will stall the bead for a frame to represent its having hit the centre of a diagonal surface
	//secondarystall means your direction is changing twice. Both of them mean you're not moving.
	bool primarystall = 0;
	bool secondarystall = 0;

	//variable that says whether or not a collision has occured; will tell us to play a sound.
	bool whack = 0;
	
	//these are the absolute boxes. they will be turned into relative boxes that depend upon the rotation (direction) of the bead.
	int bottomright = tiles[ t ]->get_type();
	int bottomleft = tiles[ t - 1 ]->get_type();
	int topright = tiles[ t - ( LEVEL_WIDTH / TILE_WIDTH ) ]->get_type();
	int topleft = tiles[ t - ( LEVEL_WIDTH / TILE_WIDTH ) - 1 ]->get_type();

	//if the stones are involved...
	for( int u = 0; u < TOTAL_STONES; u++)
	{
		//don't want an imaginary collision in top corner
		if( !stones[ u ]->get_on() ) continue;

		//stones move before beads, but it's nicer if we react to what was in the previous frame...
		int stoneX = stones[u]->get_x();
		int stoneY = stones[u]->get_y();

		//if a descending garg hits a sideways-going bullet, it should gain downward momentum. You should make a puzzle out of this (push)
		if( y == stoneY + 15 * TILE_HEIGHT / 2 && stoneX < x && x < stoneX + 8 * TILE_WIDTH ) //stone has moved onto the bead
		{			
			//if you were travelling left
			if( dir == 2 )
			{
				//we don't need to bother with the rest of the function

				//go down left
				dir = 1;

				x -= TILE_WIDTH;
				y += TILE_HEIGHT;
				
				//play the appropriate sound
				Mix_HaltChannel( 8 );
				Mix_PlayChannel( 8, glock_C, 0 );

				//I guess this means the avatar won't be harmed by a bead immediately after it hits a garg's bottom. Oh well.
				return hitangel; 
			}

			if( dir == 6 ) 
			{
				dir = 7;

				x += TILE_WIDTH;
				y += TILE_HEIGHT;
				
				Mix_HaltChannel( 14 );
				Mix_PlayChannel( 14, glock_I, 0 );
			
				return hitangel; 
			}
		}

		//whether we need to inflate the height of the stone. So by default we're in the middle
		int rounder = 0;

		//the problem is that if a bullet is travelling up to an innocent-looking bottom, it may be engulfed. Solving this breaks stones that are still
		//it's ok to get embedded in the two pixels above the stone. The stone will move down anyway. You get an uncomfy frame though.
		

		

		//either the stone is falling in which case it should be treated as being ahead of itself to avoid embedding, or it is carried, so it's not moving
		if( stoneY % 4 == 0 )
		{
			//if the stone's falling we must add to the height
			if( stones[ u ]->ismoving() ) rounder = TILE_HEIGHT / 2;
			else
			{
				//so the stone isn't going anywhere. We deduct from the height
				rounder = 0 - TILE_HEIGHT / 2;
			}
		}

		if( stoneX < x && x < (stoneX+32) ) //middle
		{
			if( y == stoneY || y == stoneY - 2 ) { bottomleft = TILE_BLOCK; bottomright = TILE_BLOCK; }
			else
			if( y == stoneY + rounder + 34 || y == stoneY + rounder + 30 ) { topleft = TILE_BLOCK; topright = TILE_BLOCK; }
		}
		else
		if( x == stoneX )					//left side
		{
			if( y == stoneY ) bottomright = TILE_BLOCK;
			else
			if( y == stoneY + rounder + 34 ) topright = TILE_BLOCK;
			else
			if( y > stoneY && y < stoneY + rounder + 34 ) { topright = TILE_BLOCK; bottomright = TILE_BLOCK; }
		}
		else
		if( x == (stoneX+8*TILE_WIDTH) )	//right side
		{
			if( y == stoneY ) bottomleft = TILE_BLOCK;
			else
			if( y == stoneY + rounder + 34 ) topleft = TILE_BLOCK;
			else
			if( stoneY < y && y < stoneY + rounder + 34 ) { bottomleft = TILE_BLOCK; topleft = TILE_BLOCK; }
		}
	}

	//if the angels are involved. In the unlikely event that this surrounds the bead entirely then kill the angel to avoid mishaps. Don't "push" this.
	//All this could be sped up a lot
	for( int u = 0; u < TOTAL_ANGELS; u++ )
	{
		//don't want an imaginary colision in top corner
		if( !angels[ u ]->get_on() ) continue;

		//if the bead is anywhere on the surface of the octagon
		//how about if two beads kill the same angel at the same time?
		if(    12 < x - angels[ u ]->get_x() && x - angels[ u ]->get_x() < 48 //if you're in the column
			&& 12 < y - angels[ u ]->get_y() && y - angels[ u ]->get_y() < 48 //and the row
			&& !( ( x - angels[ u ]->get_x() == 16 || x - angels[ u ]->get_x() == 44 ) && ( y - angels[ u ]->get_y() == 16 || y - angels[ u ]->get_y() == 44 ) ) //and you're not at the very corners
		   )
		{
			unsigned char sides = 0;

			//numbers ascend anti clockwise from the bottom
			//nondiag sides
			if( y - angels[ u ]->get_y() == 16 ) sides += 16;
			if( y - angels[ u ]->get_y() == 44 ) sides += 1;
			if( x - angels[ u ]->get_x() == 16 ) sides += 64;
			if( x - angels[ u ]->get_x() == 44 ) sides += 4;

			//diag sides
			if( y - angels[ u ]->get_y() + x - angels[ u ]->get_x() == 40 ) sides += 32;
			if( y - angels[ u ]->get_y() + x - angels[ u ]->get_x() == 80 ) sides += 2;
			if( y - angels[ u ]->get_y() == x - angels[ u ]->get_x() - 20 ) sides += 8;
			if( y - angels[ u ]->get_y() == x - angels[ u ]->get_x() + 20 ) sides += 128;

			//top left nook. These directions are wrong - what if you've just bounced?
			if( y - angels[ u ]->get_y() + x - angels[ u ]->get_x() == 36 )
			{
				if( bottomright != TILE_LEFTHANG ) bottomright = TILE_RIGHTWEDGE;
				sides = 0;

				//endanger this angel and set nook alert to the dir that a bounce on this part of the angel would cause.
				if( endangeredA == TOTAL_ANGELS )	{ endangeredA = u; nookalertA = 3; }
				else								{ endangeredB = u; nookalertB = 3; }
			}
			//bottom right nook
			if( y - angels[ u ]->get_y() + x - angels[ u ]->get_x() == 84 )
			{
				if( topleft != TILE_RIGHTWEDGE ) topleft = TILE_LEFTHANG;
				sides = 0;

				if( endangeredA == TOTAL_ANGELS )	{ endangeredA = u; nookalertA = 7; }
				else								{ endangeredB = u; nookalertB = 7; }
			}
			//top right nook
			if( y - angels[ u ]->get_y() == x - angels[ u ]->get_x() - 24 )
			{
				if( bottomleft != TILE_RIGHTHANG ) bottomleft = TILE_LEFTWEDGE;
				sides = 0;

				if( endangeredA == TOTAL_ANGELS )	{ endangeredA = u; nookalertA = 5; }
				else								{ endangeredB = u; nookalertB = 5; }
			}
			//bottom left nook
			if( y - angels[ u ]->get_y() == x - angels[ u ]->get_x() + 24 )
			{
				if( topright != TILE_LEFTWEDGE ) topright = TILE_RIGHTHANG;
				sides = 0;

				if( endangeredA == TOTAL_ANGELS )	{ endangeredA = u; nookalertA = 1; }
				else 								{ endangeredB = u; nookalertB = 1; }
			}

			//if you stick a "maybe die" variable in here. If there's a whack, they definitely die unless it's a stalled bounce. The deadly stalled bounces are handled by

			//also anti clockwise from bottom, starting with flat bit.
			if( sides == 1   )
			{
				//angel u is in danger! If 1's unused, use it
				if( endangeredA == TOTAL_ANGELS ) endangeredA = u;
				else endangeredB = u;

				//and put the relevant things into the quadrants around the bullet				
				topright = TILE_BLOCK;
				topleft = TILE_BLOCK; 
			}

			if( sides == 3   )
			{
				if( endangeredA == TOTAL_ANGELS ) endangeredA = u;
				else endangeredB = u;

				topleft = TILE_BLOCK;
				if( topright == TILE_RIGHTWEDGE ) topright = TILE_BLOCK; 
				else topright = TILE_LEFTHANG;
			}

			if( sides == 2   )
			{
				if( endangeredA == TOTAL_ANGELS ) endangeredA = u;
				else endangeredB = u;

				topleft = TILE_BLOCK;
				if( topright == TILE_RIGHTWEDGE ) topright = TILE_BLOCK; 
				else topright = TILE_LEFTHANG;
				if( bottomleft == TILE_RIGHTWEDGE ) topright = TILE_BLOCK; 
				else bottomleft = TILE_LEFTHANG;
			}

			if( sides == 6   )
			{
				if( endangeredA == TOTAL_ANGELS ) endangeredA = u;
				else endangeredB = u;

				topleft = TILE_BLOCK;
				if( bottomleft == TILE_RIGHTWEDGE ) bottomleft = TILE_BLOCK;
				else bottomleft = TILE_LEFTHANG; 
			}

			if( sides == 4   )
			{
				if( endangeredA == TOTAL_ANGELS ) endangeredA = u;
				else endangeredB = u;

				bottomleft = TILE_BLOCK;
				topleft = TILE_BLOCK; 
			}

			if( sides == 12  )
			{
				if( endangeredA == TOTAL_ANGELS ) endangeredA = u;
				else endangeredB = u;

				bottomleft = TILE_BLOCK;
				if( topleft == TILE_RIGHTHANG ) topleft = TILE_BLOCK;
				else topleft = TILE_LEFTWEDGE; 
			}

			if( sides == 8   )
			{
				if( endangeredA == TOTAL_ANGELS ) endangeredA = u;
				else endangeredB = u;

				bottomleft = TILE_BLOCK;
				if( topleft == TILE_RIGHTHANG ) topleft = TILE_BLOCK; 
				else topleft = TILE_LEFTWEDGE;
				if( bottomright == TILE_RIGHTHANG ) topleft = TILE_BLOCK; 
				else bottomright = TILE_LEFTWEDGE;
			}

			if( sides == 24  )
			{
				if( endangeredA == TOTAL_ANGELS ) endangeredA = u;
				else endangeredB = u;

				bottomleft = TILE_BLOCK;
				if( bottomright == TILE_RIGHTHANG ) bottomright = TILE_BLOCK;
				else bottomright = TILE_LEFTWEDGE;
			}

			if( sides == 16  ) 
			{
				if( endangeredA == TOTAL_ANGELS ) endangeredA = u;
				else endangeredB = u;

				bottomleft = TILE_BLOCK; 
				bottomright = TILE_BLOCK; 
			}

			if( sides == 48  ) 
			{
				if( endangeredA == TOTAL_ANGELS ) endangeredA = u;
				else endangeredB = u;

				bottomright = TILE_BLOCK;
				if( bottomleft == TILE_LEFTHANG ) bottomleft = TILE_BLOCK;
				else bottomleft = TILE_RIGHTWEDGE;
			}

			if( sides == 32  )
			{
				if( endangeredA == TOTAL_ANGELS ) endangeredA = u;
				else endangeredB = u;

				bottomright = TILE_BLOCK;
				if( bottomleft == TILE_LEFTHANG ) bottomleft = TILE_BLOCK; 
				else bottomleft = TILE_RIGHTWEDGE;
				if( topright == TILE_LEFTHANG ) topright = TILE_BLOCK; 
				else topright = TILE_RIGHTWEDGE;
			}

			if( sides == 96  )
			{
				if( endangeredA == TOTAL_ANGELS ) endangeredA = u;
				else endangeredB = u;

				bottomright = TILE_BLOCK;
				if( topright == TILE_LEFTHANG ) topright = TILE_BLOCK;
				else topright = TILE_RIGHTWEDGE;
			}

			if( sides == 64  ) 
			{
				if( endangeredA == TOTAL_ANGELS ) endangeredA = u;
				else endangeredB = u;

				bottomright = TILE_BLOCK;
				topright = TILE_BLOCK; 
			}

			if( sides == 192 )
			{
				if( endangeredA == TOTAL_ANGELS ) endangeredA = u;
				else endangeredB = u;

				topright = TILE_BLOCK;
				if( bottomright == TILE_LEFTWEDGE ) bottomright = TILE_BLOCK;
				else bottomright = TILE_RIGHTHANG;
			}

			if( sides == 128 )
			{
				if( endangeredA == TOTAL_ANGELS ) endangeredA = u;
				else endangeredB = u;

				topright = TILE_BLOCK;
				if( topleft == TILE_LEFTWEDGE ) topleft = TILE_BLOCK; 
				else topleft = TILE_RIGHTHANG;
				if( bottomright == TILE_LEFTWEDGE ) bottomright = TILE_BLOCK; 
				else bottomright = TILE_RIGHTHANG;
			}

			if( sides == 129 )
			{
				if( endangeredA == TOTAL_ANGELS ) endangeredA = u;
				else endangeredB = u;

				topright = TILE_BLOCK;
				if( topleft == TILE_LEFTWEDGE ) topleft = TILE_BLOCK;
				else topleft = TILE_RIGHTHANG;
			}

			//so the trapment thing. Are we only talking about "everything == TILE_BLOCK" or can you have a way in w/ no way out? W/ out the angel having "chased" it?
			if( topleft == TILE_BLOCK && topright == TILE_BLOCK && bottomleft == TILE_BLOCK && bottomright == TILE_BLOCK )
			{
				//MURDER THE ANGEL just in case
				hitangel = 1;
				angels[ u ]->kill( angels, release );

				//and then replace the blocks with what they were in the first place. This may get something strange, but it's all so unlikely.
				bottomright = tiles[ t ]->get_type();
				bottomleft = tiles[ t - 1 ]->get_type();
				topright = tiles[ t - ( LEVEL_WIDTH / TILE_WIDTH ) ]->get_type();
				topleft = tiles[ t - ( LEVEL_WIDTH / TILE_WIDTH ) - 1 ]->get_type();
			}
		}
	}

	//assign tile types and tile places, as they are changed by orientation
	//directly down or down-right
	if( dir == 0 || dir == 7 )
	{
		//As it is the top and left sides that are PART of the square, tiles[t] must be D
		squareD = bottomright;
		squareC = bottomleft;
		squareB = topright;
		squareA = topleft;

		lefthang = TILE_LEFTHANG;
		leftwedge = TILE_LEFTWEDGE;
		rightwedge = TILE_RIGHTWEDGE;
		righthang = TILE_RIGHTHANG;
	}
	else
	//to the left or down-left
	if( dir == 2 || dir == 1 )
	{
		squareB = bottomright;
		squareD = bottomleft;
		squareA = topright;
		squareC = topleft;

		lefthang = TILE_RIGHTHANG;
		leftwedge = TILE_LEFTHANG;
		rightwedge = TILE_LEFTWEDGE;
		righthang = TILE_RIGHTWEDGE;
	}
	else
	//up or up-left
	if( dir == 4 || dir == 3 )
	{
		squareA = bottomright;
		squareB = bottomleft;
		squareC = topright;
		squareD = topleft;

		lefthang = TILE_RIGHTWEDGE;
		leftwedge = TILE_RIGHTHANG;
		rightwedge = TILE_LEFTHANG;
		righthang = TILE_LEFTWEDGE;
	}
	else
	//right or up-right
	if( dir == 6 || dir == 5 )
	{
		squareC = bottomright;
		squareA = bottomleft;
		squareD = topright;
		squareB = topleft;

		lefthang = TILE_LEFTWEDGE;
		leftwedge = TILE_RIGHTWEDGE;
		rightwedge = TILE_RIGHTHANG;
		righthang = TILE_LEFTHANG;
	}

	//we use this to see what direction we should shake in
	int tempdir = dir;

	//work out what way to bounce. Right now you are missing the fact that any diagonal rebound can go straight into a stall.

	//if we're nondiag. This treats it all as if the bullet's going down.
	if( dir % 2 == 0 )
	{
		//go through every possible bloody combination
		if( squareC == rightwedge )
		{
			if( squareD == leftwedge )									{ dir += 4; whack = 1; }
			else
			if( squareD == lefthang || squareD == TILE_BLOCK ) //there's a surface
			{
				if( squareB == rightwedge )								{ dir += 2; whack = 1; }
				else
				if( squareB == TILE_BLOCK || squareB == leftwedge )		{ dir += 1; whack = 1; }
				else	//nowt at squareB
				{
					if( squareA == TILE_BLOCK )							{ dir += 4; whack = 1; } //very special case.
					else
					if( squareA == lefthang )							{ dir += 7; whack = 1; secondarystall = 1; }
					else												{ dir += 3; whack = 1; }
				}
			}
			//else Vel needn't be changed (there's nothing on the right)
		}
		else
		if( squareC == righthang || squareC == TILE_BLOCK ) //there's a surface
		{
			if( squareA == leftwedge )
			{
				if( squareD == leftwedge )								{ dir += 6; whack = 1; }
				else
				if( squareD == lefthang || squareD == TILE_BLOCK ) //there's a surface
				{
					if( squareB == rightwedge )							{ dir += 4; whack = 1; }
					else
					if( squareB == TILE_BLOCK || squareB == leftwedge )	{ dir += 3; whack = 1; }
					else
					if( squareB == righthang )							{ dir += 1; whack = 1; secondarystall = 1; }
					else												{ dir += 5; whack = 1; }
				}
				//else Vel needn't be changed (there's nothing on the right)
			}
			else
			if( squareA == TILE_BLOCK || squareA == rightwedge )
			{
				if( squareD == leftwedge )								{ dir += 7; whack = 1; }
				else
				if( squareD == lefthang || squareD == TILE_BLOCK ) //there's a surface
				{
					if( squareB == rightwedge )							{ dir += 5; whack = 1; }
					//else
					//if( squareB == block || squareB == leftwedge )	xVel = 		//it's impossible for the bead to be at this location
					else												{ dir += 6; whack = 1; }
				}
				//else Vel needn't be changed (there's nothing on the right)
			}
			else // there's a lefthang (special case), a righthang, or an incorporeal block at square A
			{
				if( squareD == leftwedge )
				{
					if( squareB == TILE_BLOCK )							{ dir += 4; whack = 1; } //very special case.
					else
					if( squareB == righthang )							{ dir += 1; whack = 1; secondarystall = 1; }
					else												{ dir += 5; whack = 1; }
				}
				else
				if( squareD == lefthang || squareD == TILE_BLOCK ) //there's a surface
				{
					if( squareB == rightwedge && squareA == lefthang )	{ dir += 7; whack = 1; secondarystall = 1; }
					else
					if( squareB == rightwedge )							{ dir += 3; whack = 1; }
					else
					if( squareB == TILE_BLOCK || squareB == leftwedge )	{ dir += 2; whack = 1; }
					else												{ dir += 4; whack = 1; } //there's a righthang, a lefthang (well...) , or an incorporeal block at square B and A
				}
				//else Vel needn't be changed (there's nothing on the right)
			}
		}
	}
	//if we're diag. This treats dir = 7 as default
	else
	{
		if( squareD == TILE_BLOCK || squareD == lefthang )
		{
			if( squareB == TILE_BLOCK || squareB == leftwedge )
			{
				if( squareC == TILE_BLOCK || squareC == righthang )
				{
					if( squareA == leftwedge )							{ dir += 5; whack = 1; }
					else
					if( squareA == righthang )							{ dir += 3; whack = 1; }
					else												{ dir += 4; whack = 1; }	//ain't nothing there, except for impossible things.
				}
				else
				if( squareC == rightwedge )
				{
					if( squareA == righthang )							{ dir += 2; whack = 1; }
					else												{ dir += 3; whack = 1; }	//ain't nothing there, except for inconsequential things.
				}
				else
				if( squareC == leftwedge )								
				{
					if( squareA == righthang )							{ dir += 1; whack = 1; }
					else												{ dir += 6; whack = 1; secondarystall = 1; }
				}
				else //there's nothing at squareC
				{
					if( squareA == righthang )							{ dir += 1; whack = 1; }
					else												{ dir += 2; whack = 1; }
				}
			}	
			else
			if( squareB == rightwedge )
			{
				if( squareC == TILE_BLOCK || squareC == righthang )
				{
					if( squareA == leftwedge )							{ dir += 6; whack = 1; }
					else												{ dir += 5; whack = 1; }
				}
				else
				if( squareC == rightwedge && squareA == lefthang )		{			whack = 1; secondarystall = 1; } //interesting!
				else
				if( squareC == rightwedge )								{ dir += 4; whack = 1; }
				else
				if( squareC == lefthang && squareA == leftwedge )		{ dir += 4; whack = 1; }
				else													{ dir += 3; whack = 1; } //there's nothing at squareC
			}
			else //squareB is empty or contains a righthang
			{
				if( squareC == TILE_BLOCK || squareC == righthang )
				{
					if( squareA == leftwedge )							{ dir += 7; whack = 1; }
					else												
					if( squareB == righthang )							{ dir += 2; whack = 1; secondarystall = 1; }
					else												{ dir += 6; whack = 1; }
				}
				else
				if( squareC == rightwedge )								{ dir += 5; whack = 1; }
				else //squareC is empty
				if( squareA == lefthang )								{			whack = 1; secondarystall = 1; }
				else													{ dir += 4; whack = 1; }
			}
		}
		else
		if( squareD == rightwedge )										{ dir += 4; whack = 1; primarystall = 1; }
		//else there's a righthang, a leftwedge, or an incorporeal block; dir needn't change.
	}

	//keep dir sensible
	dir = dir % 8;

	//if there's been a collision we should maybe shake?
	if( whack )
	{
		if( tempdir == 0 ) shake = 3;
		if( tempdir == 1 ) shake = 4;
		if( tempdir == 2 ) shake = 5;
		if( tempdir == 3 ) shake = 6;
		if( tempdir == 4 ) shake = 7;
		if( tempdir == 5 ) shake = 8;
		if( tempdir == 6 ) shake = 1;
		if( tempdir == 7 ) shake = 2;
	}

	//kill the angels. If there's been a non-stall collision
	if( whack )
	{
		//oh and by the way make a particle. If it's secondarystall I guess you need two particles!
		if( !secondarystall && !primarystall ) spark[rand() % 16]->relocate( x, y, dir, 0 );
		else //it's not hit at the place where the bead is...
		{
			if( dir == 1 ) spark[rand() % 16]->relocate( x+2, y-2, dir, 0 );
			if( dir == 3 ) spark[rand() % 16]->relocate( x+2, y+2, dir, 0 );
			if( dir == 5 ) spark[rand() % 16]->relocate( x-2, y+2, dir, 0 );
			if( dir == 7 ) spark[rand() % 16]->relocate( x-2, y-2, dir, 0 );
		}

		//if the placeholders have been changed, then an angel was involved in the whack.
		//stalled bullets need a special check
		//if there's an AI problem come here, previously this just checked if( primarystall )
		if( primarystall || secondarystall )
		{
			if( endangeredA != TOTAL_ANGELS && dir == nookalertA ) { hitangel = 1; if( !prediction ) angels[ endangeredA ]->kill( angels, release ); }
			if( endangeredB != TOTAL_ANGELS && dir == nookalertB ) { hitangel = 1; if( !prediction ) angels[ endangeredB ]->kill( angels, release ); }
		}
		else
		{
			//check nookalert to make sure we're not talking about a nooked bead
			if( endangeredA != TOTAL_ANGELS && nookalertA == 8 ) { hitangel = 1; if( !prediction ) angels[ endangeredA ]->kill( angels, release ); }
			if( endangeredB != TOTAL_ANGELS && nookalertB == 8 ) { hitangel = 1; if( !prediction ) angels[ endangeredB ]->kill( angels, release ); }
		}
	}

	//about to move; we make a particle where we currently are
	if( TrailCycle == 0 )
	{
		trail[ TrailParticleIndex ]->relocate( x, y, dir, 0 );
		TrailParticleIndex++;
		if( TrailParticleIndex > 15 ) TrailParticleIndex = 0;
	}
	TrailCycle++;
	if( TrailCycle == 3 ) TrailCycle = 0;

	//you know what these are
	int xVel, yVel;

	//interpret dir
	if( dir == 0 )
	{ 
		xVel = 0;
		yVel = 4;
		
		if( !prediction && whack )
		{
			//This is a little screwed up because we want a simple octagonal level
			Mix_HaltChannel( 14 );
			Mix_PlayChannel( 14, glock_I, 0 );

		}

		
	}
	else
	if( dir == 1 )
	{
		xVel = -4;
		yVel = 4;
		if( !prediction && whack )
		{
			Mix_HaltChannel( 13 );
			Mix_PlayChannel( 13, glock_H, 0 );
		}

		
	}
	else
	if( dir == 2 )
	{
		xVel = -4;
		yVel = 0;
		if( !prediction && whack )
		{
			Mix_HaltChannel( 12 );
			Mix_PlayChannel( 12, glock_G, 0 );
		}

		
	}
	else
	if( dir == 3 )
	{
		xVel = -4;
		yVel = -4;
		if( !prediction && whack )
		{
			Mix_HaltChannel( 11 );
			Mix_PlayChannel( 11, glock_F, 0 );
		}

		
	}
	else
	if( dir == 4 )
	{
		xVel = 0;
		yVel = -4;
		if( !prediction && whack )
		{
			Mix_HaltChannel( 10 );
			Mix_PlayChannel( 10, glock_E, 0 );
		}

		
	}
	else
	if( dir == 5 )
	{
		xVel = 4;
		yVel = -4;
		if( !prediction && whack )
		{
			Mix_HaltChannel( 9 );
			Mix_PlayChannel( 9, glock_D, 0 );
		}

		
	}
	else
	if( dir == 6 )
	{
		xVel = 4;
		yVel = 0;
		if( !prediction && whack )
		{
			Mix_HaltChannel( 8 );
			Mix_PlayChannel( 8, glock_C, 0 );
		}

		
	}
	else
	if( dir == 7 )
	{
		xVel = 4;
		yVel = 4;
		if( !prediction && whack )
		{
			Mix_HaltChannel( 15 );
			Mix_PlayChannel( 15, glock_J, 0 ); 
		}

		
	}

	if( !primarystall && !secondarystall )
	{
		x += xVel;
		y += yVel;
	}

	//if it's hit the edges of a level, it should "go out into infinity". 
	if( x == 0 || y == 0 || x == LEVEL_WIDTH || y == LEVEL_HEIGHT )
	{
		//make it so that when a bead goes ofscreen you make a new one without snatching the onscreen one. This is arguably dishonest
		//if I am NOT the one who's about to be replaced anyway
		if( beadcursor != myposition )
		{
			//change the cursor
			beadcursor++;

			//beadcursor does start at zero, it should never reach TOTAL_BEADS
			if( beadcursor == TOTAL_BEADS ) beadcursor = 0;
		}

		x = 0;
		y = 0;

		dir = 8;
		return hitangel;
	}
	
	//if you've not hit the avatar
	return hitangel;
}

Uint32 Bead::show( int colour, int frame )
{
	//don't bother if it's a null bead
	if( dir == 8 ) return colour;

    //Show the bead. You could do a visibility check, but there's only five of them, so...
	if( colour == 0 ) {
		apply_surface( x - camera.x - 3, y - camera.y - 3, beadpic, wall, &BeadClips[ 0 ] );
		apply_surface( x - camera.x - 3, y - camera.y - 3, beadpic, screen, &BeadClips[ 0 ] );
	}
	if( colour == 1 ){
		apply_surface( x - camera.x - 3, y - camera.y - 3, beadpic2, wall, &BeadClips[ 0 ] );
		apply_surface( x - camera.x - 3, y - camera.y - 3, beadpic2, screen, &BeadClips[ 0 ] );
	}
	if( colour == 2 ) {
		apply_surface( x - camera.x - 3, y - camera.y - 3, beadpic3, wall, &Powerclips[ (frame/2) % 12 ] );
		apply_surface( x - camera.x - 3, y - camera.y - 3, beadpic3, screen, &Powerclips[ (frame/2) % 12 ] ); 
	}

	return y * SCREEN_WIDTH + x;
}

void Bead::change( int ecks, int whyy, int dyrr )
{
	x = ecks;
	y = whyy;
	dir = dyrr;
}

//hacky function that says that the bullet is in a specific place for certain scripted sequences
bool Bead::rightplace( bool lastlevel )
{
	//if it's the last level, the place we want is between some gargoyles
	if( lastlevel )
	{
		if( y == 160 && ( x == 236 || x == 240 ) )
		{
			return 1;
		}
	}

	//and if it's not, we're wondering whether it's a bullet wall
	if( !lastlevel )
	{
		if( ( dir == 1 || dir == 5 ) && ( y >= 184 && y <= 200 ) && ( x >= 280 && x <= 296 ) )
		{
			return 1;
		}
	}
	
	return 0;
}

void Bead::vanish( particle *puff )
{
	//don't do it if the bead doesn't exist
	if( dir == 8 ) return;

	//if it does, we can put it in the right place
	puff->relocate( x, y, dir, 0 );
}

void Show_ControlKeys()
{
	if( level == 1 )
	{
		if( 200 < KeyFadeFrame && KeyFadeFrame < 209 )
		{			
			SDL_SetAlpha( keyQ, SDL_SRCALPHA, (KeyFadeFrame - 200 ) * 32 -1 ); 
			apply_surface( 154, 74, keyQ, wall, &ControlKeyClips[ 8 - (KeyFadeFrame - 200) ] );

			SDL_SetAlpha( keyW, SDL_SRCALPHA, (KeyFadeFrame - 200 ) * 32 -1 ); 
			apply_surface( 188, 65, keyW, wall, &ControlKeyClips[ 8 - (KeyFadeFrame - 200) ] );

			SDL_SetAlpha( keyE, SDL_SRCALPHA, (KeyFadeFrame - 200 ) * 32 -1 ); 
			apply_surface( 222, 74, keyE, wall, &ControlKeyClips[ 8 - (KeyFadeFrame - 200) ] );

			SDL_SetAlpha( keyA, SDL_SRCALPHA, (KeyFadeFrame - 200 ) * 32 -1 ); 
			apply_surface( 145, 108, keyA, wall, &ControlKeyClips[ 8 - (KeyFadeFrame - 200) ] );

			SDL_SetAlpha( keyD, SDL_SRCALPHA, (KeyFadeFrame - 200 ) * 32 -1 ); 
			apply_surface( 231, 108, keyD, wall, &ControlKeyClips[ 8 - (KeyFadeFrame - 200) ] );

			SDL_SetAlpha( keyZ, SDL_SRCALPHA, (KeyFadeFrame - 200 ) * 32 -1 ); 
			apply_surface( 154, 142, keyZ, wall, &ControlKeyClips[ 8 - (KeyFadeFrame - 200) ] );

			SDL_SetAlpha( keyX, SDL_SRCALPHA, (KeyFadeFrame - 200 ) * 32 -1 ); 
			apply_surface( 188, 151, keyX, wall, &ControlKeyClips[ 8 - (KeyFadeFrame - 200) ] );

			SDL_SetAlpha( keyC, SDL_SRCALPHA, (KeyFadeFrame - 200 ) * 32 -1 ); 
			apply_surface( 222, 142, keyC, wall, &ControlKeyClips[ 8 - (KeyFadeFrame - 200) ] );

			KeyFadeFrame++;
		}

		if( !pressedQ ) apply_surface( 154, 74, keyQ, wall, &ControlKeyClips[ 0 ] );
		if( !pressedW ) apply_surface( 188, 65, keyW, wall, &ControlKeyClips[ 0 ] );
		if( !pressedE ) apply_surface( 222, 74, keyE, wall, &ControlKeyClips[ 0 ] );
		if( !pressedA ) apply_surface( 145, 108, keyA, wall, &ControlKeyClips[ 0 ] );
		if( !pressedD ) apply_surface( 231, 108, keyD, wall, &ControlKeyClips[ 0 ] );
		if( !pressedZ ) apply_surface( 154, 142, keyZ, wall, &ControlKeyClips[ 0 ] );
		if( !pressedX ) apply_surface( 188, 151, keyX, wall, &ControlKeyClips[ 0 ] );
		if( !pressedC ) apply_surface( 222, 142, keyC, wall, &ControlKeyClips[ 0 ] );

		//and if one is fading?
		if( 0 < KeyFadeFrame && KeyFadeFrame < 16 ) { KeyFadeFrame--; SDL_SetAlpha( keyQ, SDL_SRCALPHA, (KeyFadeFrame % 16) * 32 ); apply_surface( 154, 74, keyQ, wall, &ControlKeyClips[ 8 - KeyFadeFrame % 16 ] ); }
		if( 16 < KeyFadeFrame && KeyFadeFrame < 32 ) { KeyFadeFrame--; SDL_SetAlpha( keyW, SDL_SRCALPHA, (KeyFadeFrame % 16) * 32 ); apply_surface( 188, 65, keyW, wall, &ControlKeyClips[ 8 - KeyFadeFrame % 16 ] ); }
		if( 32 < KeyFadeFrame && KeyFadeFrame < 48 ) { KeyFadeFrame--; SDL_SetAlpha( keyE, SDL_SRCALPHA, (KeyFadeFrame % 16) * 32 ); apply_surface( 222, 74, keyE, wall, &ControlKeyClips[ 8 - KeyFadeFrame % 16 ] ); }
		if( 48 < KeyFadeFrame && KeyFadeFrame < 64 ) { KeyFadeFrame--; SDL_SetAlpha( keyA, SDL_SRCALPHA, (KeyFadeFrame % 16) * 32 ); apply_surface( 145, 108, keyA, wall, &ControlKeyClips[ 8 - KeyFadeFrame % 16 ] ); }
		if( 64 < KeyFadeFrame && KeyFadeFrame < 80 ) { KeyFadeFrame--; SDL_SetAlpha( keyD, SDL_SRCALPHA, (KeyFadeFrame % 16) * 32 ); apply_surface( 231, 108, keyD, wall, &ControlKeyClips[ 8 - KeyFadeFrame % 16 ] ); }
		if( 80 < KeyFadeFrame && KeyFadeFrame < 96 ) { KeyFadeFrame--; SDL_SetAlpha( keyZ, SDL_SRCALPHA, (KeyFadeFrame % 16) * 32 ); apply_surface( 154, 142, keyZ, wall, &ControlKeyClips[ 8 - KeyFadeFrame % 16 ] ); }
		if( 96 < KeyFadeFrame && KeyFadeFrame < 112 ) { KeyFadeFrame--; SDL_SetAlpha( keyX, SDL_SRCALPHA, (KeyFadeFrame % 16) * 32); apply_surface( 188, 151, keyX, wall, &ControlKeyClips[ 8 - KeyFadeFrame % 16 ] ); }
		if( 112 < KeyFadeFrame && KeyFadeFrame < 128 ) { KeyFadeFrame--; SDL_SetAlpha( keyC, SDL_SRCALPHA, (KeyFadeFrame % 16) * 32 ); apply_surface( 222, 142, keyC, wall, &ControlKeyClips[ 8 - KeyFadeFrame % 16 ] ); }

	}

	if( level == 2 )
	{
		if( !pressedDOWN ) apply_surface( 734 - camera.x, 194 - camera.y, keyDOWN, wall, &ControlKeyClips[ 0 ] );
		if( !pressedLEFT ) apply_surface( 432 - camera.x, 492 - camera.y, keyLEFT, wall, &ControlKeyClips[ 0 ] );
		if( !pressedRIGHT ) apply_surface( 486 - camera.x, 180 - camera.y, keyRIGHT, wall, &ControlKeyClips[ 0 ] );

		//and if one is fading?
		if( 128 < KeyFadeFrame && KeyFadeFrame < 144 ) { KeyFadeFrame--; SDL_SetAlpha( keyDOWN, SDL_SRCALPHA, (KeyFadeFrame % 16) * 32 ); apply_surface( 734 - camera.x, 194 - camera.y, keyDOWN, wall, &ControlKeyClips[ 8 - KeyFadeFrame % 16 ] ); }
		if( 144 < KeyFadeFrame && KeyFadeFrame < 160 ) { KeyFadeFrame--; SDL_SetAlpha( keyLEFT, SDL_SRCALPHA, (KeyFadeFrame % 16) * 32 ); apply_surface( 432 - camera.x, 492 - camera.y, keyLEFT, wall, &ControlKeyClips[ 8 - KeyFadeFrame % 16 ] ); }
		if( 160 < KeyFadeFrame && KeyFadeFrame < 176 ) { KeyFadeFrame--; SDL_SetAlpha( keyRIGHT, SDL_SRCALPHA, (KeyFadeFrame % 16) * 32 ); apply_surface( 486 - camera.x, 180 - camera.y, keyRIGHT, wall, &ControlKeyClips[ 8 - KeyFadeFrame % 16 ] ); }
	}
}

Avatar::Avatar( int Ecks, int Whyy, bool ladder )
{
    //Initialize the offsets
    x = Ecks;
    y = Whyy;

	slowing = 0;

	//Initialize the amount of frames that buttons have been held down
	rightdown = 0;
	leftdown = 0;
	updown = 0;
	downdown = 0;

    //Initialize the velocity
    xVel = 0;
    yVel = 0;

	//describing animation stuff
	facingright = 1;
	onladder = ladder; //maybe there's a better way of doing this

	residue = 8;

	//not been accelerating
	acceleratingframes = 0;
}

//returns the kind of bead the player wants.
int Avatar::handle_input()
{
    //If a key was pressed.
    if( event.type == SDL_KEYDOWN )
    {
        //Adjust the velocity, create the bead
        switch( event.key.keysym.sym )
        {
			//beads
			case SDLK_q: { if( !pressedQ ) KeyFadeFrame = 8; pressedQ = 1; script = 0; residue = 3;
				if( openingscript != 0) { pressedW = 0; pressedE = 0; pressedA = 0; pressedD = 0; pressedZ = 0; pressedX = 0; pressedC = 0;openingscript = 0; }
				return 3; } break;
			case SDLK_w: { if( !pressedW ) KeyFadeFrame = 24; pressedW = 1; script = 0; residue = 4;
				if( openingscript != 0) { pressedQ = 0;	pressedE = 0; pressedA = 0; pressedD = 0; pressedZ = 0; pressedX = 0; pressedC = 0;openingscript = 0; }
				return 4; } break;
			case SDLK_e: { if( !pressedE ) KeyFadeFrame = 40; pressedE = 1; script = 0; residue = 5;
				if( openingscript != 0) { pressedQ = 0;	pressedW = 0; pressedA = 0; pressedD = 0; pressedZ = 0; pressedX = 0; pressedC = 0;openingscript = 0; }
				return 5; } break;
			case SDLK_a: { if( !pressedA ) KeyFadeFrame = 56; pressedA = 1; script = 0; residue = 2;
				if( openingscript != 0) { pressedQ = 0;	pressedW = 0; pressedE = 0; pressedD = 0; pressedZ = 0; pressedX = 0; pressedC = 0;openingscript = 0; }
				return 2; } break;
			case SDLK_d: { if( !pressedD ) KeyFadeFrame = 72; pressedD = 1; script = 0; residue = 6;
				if( openingscript != 0) { pressedQ = 0;	pressedW = 0; pressedE = 0; pressedA = 0; pressedZ = 0; pressedX = 0; pressedC = 0;openingscript = 0; }
				return 6; } break;
			case SDLK_z: { if( !pressedZ ) KeyFadeFrame = 88; pressedZ = 1; script = 0; residue = 1;
				if( openingscript != 0) { pressedQ = 0;	pressedW = 0; pressedE = 0; pressedA = 0; pressedD = 0; pressedX = 0; pressedC = 0;openingscript = 0; }
				return 1; } break;
			case SDLK_x: { if( !pressedX ) KeyFadeFrame = 104; pressedX = 1; script = 0; residue = 0;
				if( openingscript != 0) { pressedQ = 0;	pressedW = 0; pressedE = 0; pressedA = 0; pressedD = 0; pressedZ = 0; pressedC = 0;openingscript = 0; }
				return 0; } break;
			case SDLK_c: { if( !pressedC ) KeyFadeFrame = 120; pressedC = 1; script = 0; residue = 7;
				if( openingscript != 0) { pressedQ = 0;	pressedW = 0; pressedE = 0; pressedA = 0; pressedD = 0; pressedZ = 0; pressedX = 0;openingscript = 0; }
				return 7; } break;

			//avatar moving
			case SDLK_i:    { updown = 1; }			break;
			case SDLK_k:  { if( !pressedDOWN ) KeyFadeFrame = 136; if( level == 2 ) pressedDOWN = 1; downdown = 1; }		break;
			case SDLK_j:  { if( !pressedLEFT ) KeyFadeFrame = 152; if( level == 2 ) pressedLEFT = 1; leftdown = 1; }		break;
			case SDLK_l: { if( !pressedRIGHT ) KeyFadeFrame = 168; if( level == 2 ) pressedRIGHT = 1; rightdown = 1; }		break;

		
			case SDLK_UP:    { updown = 1; }			break;
			case SDLK_DOWN:  { if( !pressedDOWN ) KeyFadeFrame = 136; if( level == 2 ) pressedDOWN = 1; downdown = 1; }		break;
			case SDLK_LEFT:  { if( !pressedLEFT ) KeyFadeFrame = 152; if( level == 2 ) pressedLEFT = 1; leftdown = 1; }		break;
			case SDLK_RIGHT: { if( !pressedRIGHT ) KeyFadeFrame = 168; if( level == 2 ) pressedRIGHT = 1; rightdown = 1; }		break;

			

			//remove this!
			case SDLK_p: if( level != LAST_LEVEL ) level++; break;
			case SDLK_o: if( level != 1 ) level--; break;

			//restart game
			case SDLK_BACKSPACE: 
			{
				level = 1;
				pressedQ = 0;
				pressedW = 0;
				pressedE = 0;
				pressedA = 0;
				pressedD = 0;
				pressedZ = 0;
				pressedX = 0;
				pressedC = 0;
				pressedR = 0;
				pressedDOWN = 0;
				pressedLEFT = 0;
				pressedRIGHT = 0;
			} break;

			//restart
			case SDLK_t: { if( level == 11 ) pressedR = 1; if( level != LAST_LEVEL ) restart = 1; } break;
        }

		//if absolutely any key was pressed, the avatar can recover from shock
		script = 0;

		//We don't want the player moving down while they're already moving down on a garg...
		if( level == LAST_LEVEL ) { updown = 0; downdown = 0; }
    }
    //If a key was released
    else if( event.type == SDL_KEYUP )
    {
        //Adjust the velocity
        switch( event.key.keysym.sym )
        {
			case SDLK_i:    { updown = 0; acceleratingframes = 0; } break;
			case SDLK_k:  { downdown = 0; acceleratingframes = 0; } break;
            case SDLK_j:  { leftdown = 0; acceleratingframes = 0; } break;
            case SDLK_l: { rightdown = 0; acceleratingframes = 0; } break;	
           	

			
			case SDLK_UP:    { updown = 0; acceleratingframes = 0; } break;
			case SDLK_DOWN:  { downdown = 0; acceleratingframes = 0; } break;
            case SDLK_LEFT:  { leftdown = 0; acceleratingframes = 0; } break;
			case SDLK_RIGHT: { rightdown = 0; acceleratingframes = 0; } break;	
			
        }
    }

	//the player doesn't want a new bead
	return 8;
}

bool Avatar::stonewalk( stone *stones[], int tile_position )
{
	//get the x and y values from the tile's position
	int tileX = ( tile_position % ( LEVEL_WIDTH / TILE_WIDTH ) ) * TILE_WIDTH;
	int tileY = TILE_HEIGHT * ( tile_position - ( tile_position % ( LEVEL_WIDTH / TILE_WIDTH ) ) ) / ( LEVEL_WIDTH / TILE_WIDTH );

	//go through the stones
	for( int u = 0; u < TOTAL_STONES; u++ )
	{
		//if you're just above the top left of the stone
		//if you're mid square then you're down.
		if(  ( stones[ u ]->get_y() == tileY + 4 || stones[ u ]->get_y() == y + AVATAR_HEIGHT ) //avatar height check just in case tiles are unreliable
			&& stones[ u ]->get_x() - TILE_WIDTH * 3 <= tileX && tileX <= stones[ u ]->get_x() + TILE_WIDTH * 7
			)
		{
			//there's a stone in the right spot, the avatar is fine to be here.
			return 1;
		}
	}

	return 0;
}
int Avatar::accel( int Vel, bool buttondown, int framecount )
{
	//a fact to bear in mind: sometimes xVel simply needn't be changed.
	//if player wants to go right and we're not slowing down
	if( buttondown && !slowing )
	{
		//if we're standing still
		if( !xVel && !yVel )
		{
			if( framecount % 8 == 0 ) { Vel = 1; alignment = 0; }
			else
			if( framecount % 8 == 4 ) { Vel = 1; alignment = 1; }
		}
		else //so we're not still
		if( Vel != 4 ) //so we're speeding up
		{
			if( !alignment )
			{
				if( framecount % 8 == 0 ) Vel++;
			}
			else //alignment is 1.
			{
				if( framecount % 8 == 4 ) Vel++;
			}
		}
	}
	else //player is slowing down, or wants to slow down, or is still.
	if( Vel ) //we're not still, so the player wants to slow to a stop.
	{
		if( slowing ) //there's already been a frame of slowing down.
		{
			if( Vel == 3 ) Vel = 1;
			else //Vel is 1.
			{
				Vel = 0;
				slowing = 0;
			}
		}
		else
		//if you were in the process of speeding up (i.e. you're not at full speed)
		if( Vel != 4 )
		{
			if( framecount % 4 == 0 ) Vel = 0;
			else
			if( Vel == 2 && framecount % 2 == 0 ) Vel = 0;
			//so Vel won't change at all if we're not at the right time.
		}
		else //so we're at full speed, xVel = 4.
		if( framecount % 2 == 0 ) //
		{
			Vel = 3;
			slowing = 1;
		}
	}

	return Vel;
}

//moves t'avatar
void Avatar::move( Tile *tiles[], stone *stones[], int framecount )
{
	//"fall" part. If the movement of a garg has left you hanging (using the yVel > 0 square may be a mistake)
	if( tiles[ ( (y+31) - ( (y+31) % 4 ) ) * LEVEL_WIDTH / 16 + ( x - ( x % 4 ) ) / 4 ]->get_type() != TILE_FLOOR )
	{
		//fall
		y += TILE_HEIGHT;

		//go through the gargoyles
		for( int u = 0; u < TOTAL_STONES; u++ )
		{
			//if you've ended up inside one
			if(    stones[ u ]->get_x() < x + AVATAR_WIDTH  && stones[ u ]->get_x() + 8 * TILE_WIDTH > x
				&& stones[ u ]->get_y() < y + AVATAR_HEIGHT && y + AVATAR_HEIGHT <= stones[ u ]->get_y() + TILE_HEIGHT
				)
			{				
				//move it back by the amount that you are in (either 2 or 4)
				y -= ( (y + AVATAR_HEIGHT) - stones[ u ]->get_y() );
			}
		}		
	}




	//if the vels are in a condition to be increased, accelerate them.
	if( yVel == 0 && xVel > -1 ) xVel = accel( xVel, rightdown, framecount );
	if( yVel == 0 && xVel < 1 ) xVel = -accel( -xVel, leftdown, framecount );

	if( xVel == 0 && yVel > -1 ) yVel = accel( yVel, downdown, framecount );
	if( xVel == 0 && yVel < 1 ) yVel = -accel( -yVel, updown, framecount );

	//Move the avatar left or right
    x += xVel;

	//Move the avatar up or down
    y += yVel;

	//if the player is in stone
	bool carbonite = 0;

	//check for gargoyles
	for( int g = 0; g < TOTAL_STONES; g++ )
	{
		if(    ( x + 4 * TILE_WIDTH > stones[ g ]->get_x() && x < stones[ g ]->get_x() + 8 * TILE_WIDTH )
			&& ( y + 8 * TILE_WIDTH > stones[ g ]->get_y() && y < stones[ g ]->get_y() + 8 * TILE_WIDTH )
			)
		{
			carbonite = 1;
		}
	}	

	//if we're off a ledge or off a cliff or we've gone up or down when there's no ladder.
	//if you've gone right
	if(	   xVel > 0 && 
		(  tiles[ ( y - ( y % 4 ) + 28 ) * LEVEL_WIDTH / 16 + ( x+3 - ( (x+3) % 4 ) ) / 4 ]->get_type() != TILE_FLOOR 
		|| carbonite )
		)
	{
		//if there's a stone in the right place, no need to move shit back
		if( stonewalk( stones, ( y - ( y % 4 ) + 28 ) * LEVEL_WIDTH / 16 + ( x+3 - ( (x+3) % 4 ) ) / 4 ) ) return;

		//if( xVel > 1 ) Mix_PlayChannel( 4, bass, 0 );

		if( x % 4 != 0 ) x -= ( x % 4 ); //Move back to the closest sensible place.
		else x -= 4;

		xVel = 0;

		//and just in case
		slowing = 0;
	}

	//if you've gone left
	if(	   xVel < 0 &&
		(  tiles[ ( y - ( y % 4 ) + 28 ) / TILE_WIDTH * LEVEL_WIDTH / TILE_WIDTH + ( x - ( x % 4 ) ) / 4 ]->get_type() != TILE_FLOOR //if there's no floor tile
		|| carbonite )//or if you've walked into a gargoyle.
		)
	{
		//if there's a stone in the right place, don't worry about it. Let's hope this doesn't negate the carbonite check COME HERE IF YOU HAVE PROBLEMS
		if( stonewalk( stones, ( y - ( y % 4 ) + 28 ) / TILE_WIDTH * LEVEL_WIDTH / TILE_WIDTH + ( x - ( x % 4 ) ) / 4 ) ) return;

		//you've hit something, make a sound, unless you weren't really moving
		//if( xVel < -1 ) Mix_PlayChannel( 4, bass, 0 );

		if( x % 4 != 0 ) x += ( 4 - x % 4 ); //Move back to the closest sensible place.
		else x += 4;

		xVel = 0;

		slowing = 0;
	}

	if(	   yVel < 0 &&
		(  tiles[ ( y - ( y % 4 ) + 28 ) * LEVEL_WIDTH / 16 + ( x - ( x % 4 ) ) / 4 ]->get_type() != TILE_FLOOR 
		|| carbonite )
		)
	{
		//no need to stonecheck, you can't ascend into a stone.

		//if( yVel < -1 ) Mix_PlayChannel( 4, bass, 0 );

		if( y % 4 != 0 ) y += ( 4 - y % 4 ); //Move back to the closest sensible place.
		else y += 4;

		yVel = 0;

		slowing = 0;
	}

	//nothin' different about this one.
	if(	   yVel > 0 && 
		(  tiles[ ( (y+31) - ( (y+31) % 4 ) ) * LEVEL_WIDTH / 16 + ( x - ( x % 4 ) ) / 4 ]->get_type() != TILE_FLOOR 
		|| carbonite )
		)
	{
		//if there's a stone in the right place, don't worry about it.
		if( stonewalk( stones, ( (y+31) - ( (y+31) % 4 ) ) * LEVEL_WIDTH / 16 + ( x - ( x % 4 ) ) / 4 ) ) return;

		//if( yVel > 1 ) Mix_PlayChannel( 4, Drum_G, 0 );

		if( y % TILE_HEIGHT != 0 ) y -= ( y % TILE_HEIGHT ); //Move back to the closest sensible place.
		else y -= TILE_HEIGHT;

		yVel = 0;

		slowing = 0;		
	}

	//if( x % 4 != 0 || y % 4 != 0 && framecount % 8 == 0 ) WARNING WARNING DANGER DANGER!!;

	//for the sake of animation, we check if the square we're on is a ladder, using the same check we used to see whether ascent or descent is permitted
	//though we only do this after moving, otherwise the parts where the ladder is the whole level fuck up
	if( xVel != 0 || yVel != 0 )
	{
		if( tiles[ ( (y+31) - ( (y+31) % 4 ) ) * LEVEL_WIDTH / 16 + ( x - ( x % 4 ) ) / 4 - LEVEL_WIDTH / TILE_WIDTH ]->get_type() == TILE_FLOOR
			|| tiles[ ( (y+31) - ( (y+31) % 4 ) ) * LEVEL_WIDTH / 16 + ( x - ( x % 4 ) ) / 4 + LEVEL_WIDTH / TILE_WIDTH ]->get_type() == TILE_FLOOR )
			onladder = 1;
		else
			onladder = 0;
	}
}

void Avatar::show( int frame, int beaddirection, particle *trail[] )
{
	//this is the opening animation
	if( openingscript)
	{
		//some variables related to the sling
		int distaboveyou = 30;
		int framesspentfloating = 48;
		int framewhentheslingarrives = 148;

		//these are the location of the CENTER of the floating sling
		int slingX = x + 8;
		int slingY = y - distaboveyou;

		//the location of the sling is defined by frame
		if( frame >= framewhentheslingarrives )
		{
			//three spins while floating is ok, so we start its descent after that
			if( frame == framewhentheslingarrives + framesspentfloating )
			{
				slingY = y - distaboveyou;
			}
			else
			if( frame == framewhentheslingarrives + framesspentfloating + 1 )
			{
				slingY = y - distaboveyou + 1;
			}
			else
			if( frame == framewhentheslingarrives + framesspentfloating + 2 )
			{
				slingY = y - distaboveyou + 2;
			}
			else
			if( frame == framewhentheslingarrives + framesspentfloating + 3 )
			{
				slingY = y - distaboveyou + 4;
			}
			else
			if( frame == framewhentheslingarrives + framesspentfloating + 4 )
			{
				slingY = y - distaboveyou + 6;
			}
			else
			if( frame == framewhentheslingarrives + framesspentfloating + 5 )
			{
				slingY = y - distaboveyou + 9;
			}
			else
			if( frame == framewhentheslingarrives + framesspentfloating + 6 )
			{
				slingY = y - distaboveyou + 12;
			}
			else
			if( frame > framewhentheslingarrives + framesspentfloating + 6 )
			{
				//So this the sling's original location plus the dist while accelerating, plus the topspeed times the amount of frames it's been going the top speed for
				slingY = y - distaboveyou + 12 + 4 * ( frame - (framewhentheslingarrives + framesspentfloating + 6) );
			}

			//when it enters your hand, play a sound and shake
			if( slingY == y + 6 )
			{
				Mix_PlayChannel( 2, crotales, 0 );
				shake = 12;
			}
		}

		//openingscript is defined by frame
		if( frame < 50 ) openingscript = 1; //sleep
		else
		if( frame < 90 ) openingscript = 2; //wake
		else
		if( frame < 98 ) openingscript = 3; //get up
		else
		if( frame < 118 ) openingscript = 4; //stand (want this to be longer, and have him look both ways
		else
		if( slingY >= y + 16 ) openingscript = 6; //if it's in your hand
		else
		openingscript = 5; //shock. This gets changed when the sling enters your hand

		//now we show the things. Sling first since the avatar is looking into the screen
		//first we have the magical intro of the sling
		if( frame >= 114 && frame <= 130 ) //this is whatever the upper limit on openingscript = 4 is. Minus a little so the avatar takes some time to notice
		{
			//there are specific things you do at the beginning
			if( frame == 114 )
			{
				//shake the screen to introduce it
				shake = 12;

				//play a low sound
				Mix_PlayChannel( 2, la, 0 );
			}

			//you alter the alpha quantity so it fades in
			SDL_SetAlpha( slingfadein, SDL_SRCALPHA, 128 - (120 - frame) * 7 );

			//make a rectangle here, why complicate things?
			SDL_Rect slingfadeinclip = { 96 * (frame-114), 0, 96, 96 };

			//then show it
			apply_surface( slingX - camera.x - 48, slingY - camera.y - 48, slingfadein, wall, &slingfadeinclip );
		}
		//this is the proper sling
		if( frame > 130 && openingscript == 5 )
		{
			//make rectangle
			SDL_Rect slingclip = { 16 * ( (frame-131) % 16 ), 0, 16, 16 };

			//show
			apply_surface( slingX - camera.x - 8, slingY - camera.y - 8, sling, wall, &slingclip );
		}

		if( frame == 302 ) KeyFadeFrame = 201;
		//once we've done lots of stuff, we bring in the button prompts
		if( frame == 310 )
		{
			pressedQ = 0;
			pressedW = 0;
			pressedE = 0;
			pressedA = 0;
			pressedD = 0;
			pressedZ = 0;
			pressedX = 0;
			pressedC = 0;
		}

		//make a rectangle for t'avatar
		SDL_Rect openingclip = { 18 * (openingscript-1), 0, 18, 32 };

		//then show the avatar
		apply_surface( x - camera.x - 1, y - camera.y, openingavatar, wall, &openingclip );

		//also we don't need to show the rest of the avatar
		return;
	}

	//if we're in the final place, it's exceptional
	if( script )
	{
		//shocked image
		apply_surface( x - camera.x, y - camera.y, avatarshocked, wall, &shockedclips[ script - 1 ] );

		//oh and by the way we need to stop you moving if you were at all
		if( script == 1 || ( script == 4 && camera.y > 92 ) )
		{
			updown = 0;
			downdown = 0;
			leftdown = 0;
			rightdown = 0;
		}

		//and that's all we need
		return;
	}

	//shooting in the opposite direction to the one you're walking in? For the legs, play the animation going in the direction you're facing in reverse

	//this sort of thing needs to be done every frame, might as well be here
	//we'd prefer it to be that if the floortile you're on is actually a ladder, you're onladder.
	if( xVel != 0 )
	{
		if( xVel > 0 ) facingright = 1;
		else facingright = 0;
	}


	//if you're gonna throw in certain directions. You have it here so the character instantly turns if you wanna shoot
	if( beaddirection == 1 || beaddirection == 2 || beaddirection == 3 ) facingright = 0;
	if( beaddirection == 5 || beaddirection == 6 || beaddirection == 7 ) facingright = 1;

	//first, legs	

	//moving up or down...
	if( yVel < 0 )
	{
		apply_surface( x - camera.x - 8, y - camera.y, avatarclimbing, wall, &climbing[ frame % 16 ] );

		if( frame % 16 == 0 || frame % 16 == 9 ) {
			if( foot )
			{
				Mix_HaltChannel( 3 );
				Mix_PlayChannel( 3, ladderstep1, 0 );

				foot = 0;
			}
			else
			{
				Mix_HaltChannel( 4 );
				Mix_PlayChannel( 4, ladderstep2, 0 );

				foot = 1;
			}
		}
	}
	else
	if( yVel > 0 )
	{
		apply_surface( x - camera.x - 8, y - camera.y, avatarclimbing, wall, &climbing[ frame % 16 ] );

		if( frame % 16 == 0 || frame % 16 == 9 ) {
			if( foot )
			{
				Mix_HaltChannel( 3 );
				Mix_PlayChannel( 3, ladderstep1, 0 );

				foot = 0;
			}
			else
			{
				Mix_HaltChannel( 4 );
				Mix_PlayChannel( 4, ladderstep2, 0 );

				foot = 1;
			}
		}
	}

	else

	//moving left or right...
	if( xVel > 0 )
	{
		//if you've completed the extra, fake acceleration (and you'll certainly have accelerated by this point
		if( acceleratingframes > 23 )
		{
			if( acceleratingframes == 24 ) acceleratingframes = 25;
			//which frame we show is tied to when the acceleration animation completed.
			apply_surface( x - camera.x - 3, y - camera.y - 8, avatarrunning, wall, &running[ (acceleratingframes-25) / 3 ] );

			acceleratingframes++;

			if( acceleratingframes == 49 ) acceleratingframes = 25;			
		}

		//otherwise
		else
		{ 
			//show the acceleration frame, fake or otherwise
			apply_surface( x - camera.x - 3, y - camera.y, avataraccelerating, wall, &accelerating[ acceleratingframes ] );

			//the avatar's acceleration frames change in a variable way. Initially it's full speed
			if( acceleratingframes < 12 ) acceleratingframes++;			
			//then slowesr
			else
			if( acceleratingframes < 24 && frame % 2 == 0 ) acceleratingframes++;
		}

		//we play a drum if the frame is one where the avatar has just put a foot down i.e. frame 3 or 7 in the looped animation, or 0, 7, 14, 19, 23 accelerating animation
		//37, 46, 
		if( acceleratingframes == 35 || acceleratingframes == 47
			|| acceleratingframes == 1 || acceleratingframes == 8
			|| (acceleratingframes == 15 && frame % 2 == 0) || (acceleratingframes == 24 && frame % 2 == 0) || (acceleratingframes == 20 && frame % 2 == 0)
			)
		{
			//volume increases with speed
			//Mix_Volume( 4, 2 + acceleratingframes / 4 );
			//Mix_Volume( 3, 2 + acceleratingframes / 4 );

			//which note we play depends on foot
			if( foot )
			{
				Mix_HaltChannel( 3 );
				Mix_PlayChannel( 3, footstep1, 0 );

				foot = 0;
			}
			else
			{
				Mix_HaltChannel( 4 );
				Mix_PlayChannel( 4, footstep2, 0 );

				foot = 1;
			}
		}
	}
	else
	if( xVel < 0 )
	{
		//if you've completed the extra, fake acceleration (and you'll certainly have accelerated by this point
		if( acceleratingframes > 23 )
		{
			if( acceleratingframes == 24 ) acceleratingframes = 25;

			//which frame we show is tied to when the acceleration animation completed.
			apply_surface( x - camera.x - 3, y - camera.y - 8, avatarrunning, wall, &running[ (acceleratingframes-25) / 3 + 8 ] );

			acceleratingframes++;

			if( acceleratingframes == 49 ) acceleratingframes = 25;	
		}

		//otherwise
		else
		{
			//show the acceleration frame, fake or otherwise
			apply_surface( x - camera.x - 3, y - camera.y, avataraccelerating, wall, &accelerating[ acceleratingframes +24 ] );

			//the avatar's acceleration frames change in a variable way. Initially it's full speed
			if( acceleratingframes < 12 ) acceleratingframes++;			
			//then slowesr
			else
			if( acceleratingframes < 24 && frame % 2 == 0 ) acceleratingframes++;
		}

		//we play a drum if the frame is one where the avatar has just put a foot down i.e. frame 4 or 7 in the looped animation, or 0,7, 14, 19, 23 accelerating animation
		//frame 
		if( acceleratingframes == 35 || acceleratingframes == 47
			|| acceleratingframes == 1 || acceleratingframes == 8
			|| (acceleratingframes == 15 && frame % 2 == 0) || (acceleratingframes == 24 && frame % 2 == 0) || (acceleratingframes == 20 && frame % 2 == 0)
			)
		{

			//which note we play depends on foot
			if( foot )
			{
				Mix_PlayChannel( 3, footstep1, 0 );

				foot = 0;
			}
			else
			{
				Mix_PlayChannel( 4, footstep2, 0 );

				foot = 1;
			}
		}
	}
	else

		//after accelerating[ 23 ] should come running[3]

	//if he's on a ladder and not moving
	if( onladder ) apply_surface( x - camera.x, y - camera.y, avataronladder, wall );

	//[legs] just standing
	else apply_surface( x - camera.x + 1 - facingright * 2, y - camera.y, avatarstanding, wall, &standing[ facingright * 16 ] );


	//now, upper body

	//if we're going to create a bead, and we're in the last 6 frames of a cycle, start throwing in that direction
	if( beaddirection != 8 && frame % 16 > 6 )
	{
		//exceptional cases where for up and down you have to incorporate facingright
		if( facingright && beaddirection == 0 )
		{
			if( (frame % 16) / 4 == 1 ) apply_surface( x - camera.x - 8, y - camera.y - 10, avatarthrowing, wall, &throwing[ 27 ] );
			if( (frame % 16) / 4 == 2 ) apply_surface( x - camera.x - 8, y - camera.y - 10, avatarthrowing, wall, &throwing[ 28 ] );
			if( (frame % 16) / 4 == 3 ) apply_surface( x - camera.x - 8, y - camera.y - 10, avatarthrowing, wall, &throwing[ 29 ] );
		}
		else
		if( facingright && beaddirection == 4 )
		{
			if( (frame % 16) / 4 == 1 ) apply_surface( x - camera.x - 8, y - camera.y - 10, avatarthrowing, wall, &throwing[ 24 ] );
			if( (frame % 16) / 4 == 2 ) apply_surface( x - camera.x - 8, y - camera.y - 10, avatarthrowing, wall, &throwing[ 25 ] );
			if( (frame % 16) / 4 == 3 ) apply_surface( x - camera.x - 8, y - camera.y - 10, avatarthrowing, wall, &throwing[ 26 ] );
		}
		else
		if( facingright )
		{
			if( (frame % 16) / 4 == 1 ) apply_surface( x - camera.x - 8, y - camera.y - 10, avatarthrowing, wall, &throwing[ 3 * beaddirection ] );
			if( (frame % 16) / 4 == 2 ) apply_surface( x - camera.x - 8, y - camera.y - 10, avatarthrowing, wall, &throwing[ 3 * beaddirection + 1 ] );
			if( (frame % 16) / 4 == 3 ) apply_surface( x - camera.x - 8, y - camera.y - 10, avatarthrowing, wall, &throwing[ 3 * beaddirection + 2 ] );
		}
		else
		{

			//takes the right frame out of the 3x8 sheet
			if( (frame % 16) / 4 == 1 ) apply_surface( x - camera.x - 12, y - camera.y - 10, avatarthrowing, wall, &throwing[ 3 * beaddirection ] );
			if( (frame % 16) / 4 == 2 ) apply_surface( x - camera.x - 12, y - camera.y - 10, avatarthrowing, wall, &throwing[ 3 * beaddirection + 1 ] );
			if( (frame % 16) / 4 == 3 ) apply_surface( x - camera.x - 12, y - camera.y - 10, avatarthrowing, wall, &throwing[ 3 * beaddirection + 2 ] );

		}
	}
	else
	if( frame % 16 == 0 && residue != 8 )
	{
		if( facingright && residue == 0 ) apply_surface( x - camera.x - 8, y - camera.y - 10, avatarthrowing, wall, &throwing[ 29 ] );
		else
		if( facingright && residue == 4 ) apply_surface( x - camera.x - 8, y - camera.y - 10, avatarthrowing, wall, &throwing[ 26 ] );
		else
		if( facingright ) apply_surface( x - camera.x - 8, y - camera.y - 10, avatarthrowing, wall, &throwing[ 3 * residue + 2 ] );
		else   apply_surface( x - camera.x - 12, y - camera.y - 10, avatarthrowing, wall, &throwing[ 3 * residue + 2 ] );

		//put residue the way it should be
		residue = 8;
	}
	else
	//no bead shooting? Well then we just get the upper half of the body, dependent on frame maybe.
	if( !onladder )
	{
		if( NoBeadOverride ) apply_surface( x - camera.x, y - camera.y, avatartorso, wall, &standing[ facingright * 16 + 7 ] );
		else apply_surface( x - camera.x, y - camera.y, avatartorso, wall, &standing[ facingright * 16 + frame % 16 ] );

		NoBeadOverride = 0;
	}
	else
	{
		if( NoBeadOverride ) apply_surface( x - camera.x - 3, y - camera.y, avatarclimbingswinging, wall, &climbingswinging[ 8 ] );
		else apply_surface( x - camera.x - 3, y - camera.y, avatarclimbingswinging, wall, &climbingswinging[ frame % 16 ] );		

		NoBeadOverride = 0;
	}
	

	//To stop on a ladder, upper part of body grabs the side of the ladder, then legs just go through the frames they need to to get back to the right place.
}

void Avatar::set_camera()
{
    //Center the camera over the avatar. The center of the screen is the place from whence the bullets shall come.
    camera.x = ( x + AVATAR_WIDTH / 2 ) - SCREEN_WIDTH / 2;
    camera.y = ( y + AVATAR_HEIGHT / 2 ) - SCREEN_HEIGHT / 2 - 8;

    //Stay the fuck inside the bounds of the level.
}

stone::stone( int Ecks, int Whyy )
{
	x = Ecks;
	y = Whyy;

	//this may be changed immediately but things shouldn't come into existence in movement
	moving = 0;

	//you want to fade in
	easingin = 1;

	//whether it exists or not, it isn't a particle
	justaparticle = 0;

	GlowStrength = rand() % 128;
	GlowVel = 4;

	//if we put it in the top left corner, that means we don't want it
	if( x == 0 && y == 0 ) on = 0;
	else on = 1;
}
bool stone::get_on()
{
	return on;
}

void stone::move( Tile *tiles[], angel *angels[], int framecount )
{
	//so it's not moving. If it moves later in this function, this gets changed
	moving = 0;

	//if the stone is nonexistant, nothing happens. If it's just a particle, it doesn't move
	if( !on || justaparticle ) return;

	//If the player is standing on you, you can't be mid-square during an odd framecount, otherwise a misaligned bullet would be possible
	//there again it could be that the player only stands on you in the last level
	if( ( framecount % 2 == 0 && y % TILE_WIDTH != 0 ) || ( framecount % 2 != 0 && y % TILE_WIDTH == 0 ) )
	{
		return;
	}

	//the number of the block that is just underneath the bottom left corner of the gargoyle. 8 is the number of squares high it is.
	int t = ( y - ( y % TILE_WIDTH ) + TILE_WIDTH * 8 ) / TILE_WIDTH * LEVEL_WIDTH / TILE_WIDTH + x / TILE_WIDTH;

	//if you're in the middle of a square, there's no way an angel can catch you
	if( y % 4 == 0 )
	{
		//go through the angels
		for( int i = 0; i < TOTAL_ANGELS; i++ )
		{
			//there is an angel beneath you
			if(	 angels[ i ]->get_y() + 4 * TILE_HEIGHT == y + 8 * TILE_WIDTH

				 //angel.x + 9 tiles == x would mean folding the left wing in
				 && x < angels[ i ]->get_x() + 9 * TILE_WIDTH

				 //angel.x + 6 tiles == x + 8 would mean folding the right wing in
				 && angels[ i ]->get_x() + 6 * TILE_WIDTH < x + 8 * TILE_WIDTH
				 )
			{
				return; //and change the angel's sprite. And make a sound?
			}
		}
	}

	//also if you've reached the bottom of the level
	if( y == LEVEL_HEIGHT - 8 * TILE_HEIGHT )
	{
		//so die
		on = 0;

		return;
	}

	//for all the blocks beneath you
	for( int i = 0; i < 8; i++ )
	{
		//if there's a non-ephemeral block then you've hit something
		if( tiles[ t + i ]->get_type() != TILE_GLASS && tiles[ t + i ]->get_type() != TILE_FLOOR )
		{
			//so turn into a particle. And the end of your animation, turn off.
			justaparticle = 1;

			//make the screen shake!
			shake = 12;

			//also make a noise like a crotales. Might as well be channel 6.
			Mix_PlayChannel( 6, drum, 0 );

			return;
		}
	}

	

	//if we've reached this point there are no angels. So we should move

	y += 2;
	moving = 1;

	return;
}

void stone::show( particle *gargpuffs[] )
{
	//if you're not here, don't be seen.
	if( !on ) return;

	//here we do everything we do if we're only a particle
	if( justaparticle )
	{
		//we make a rectangle, and adjust it according to justaparticle, a number which now describes our frame
		SDL_Rect frame = { (justaparticle-1) * 64, 0, 64, 64 };

		//we want this to fade out
		SDL_SetAlpha( stonegoes, SDL_SRCALPHA, 255 - (justaparticle-1) * 16 );

		//show the frame of the death animation
		apply_surface( x - camera.x - 16, y - camera.y - 16, stonegoes, screen, &frame );

		//update this quantity now we've been shown
		justaparticle++;

		//if you're done with the animation, there's nowt more to be done with you
		if( justaparticle == 16 ) { on = 0; justaparticle = 0; }
	}

	else
	//if you've just been created
	if( easingin )
	{
		//we make a rectangle, and adjust it according to easingin, a number which now describes our frame
		SDL_Rect frame = { ( 16 - easingin ) * 64, 0, 64, 64 };

		//we want this to fade out
		SDL_SetAlpha( stonegoes, SDL_SRCALPHA, 255 - (16 - easingin) * 16 );

		//show the frames of the death animation backwards
		apply_surface( x - camera.x - 16, y - camera.y - 16, stonegoes, screen, &frame );

		//progress the animation
		easingin++;

		//if you're done, stop this happening
		if( easingin == 17 ) easingin = 0;
	}
	else
    //Not being created or destroyed? Well, show the stone
	{
		if( moving )
		{
			if( GlowVel == 4 || GlowVel == -4 ) GlowVel *= 2;

			if( GlowStrength - 96 >= 0 ) SDL_SetAlpha( stoneglow, SDL_SRCALPHA, GlowStrength - 96 ); else SDL_SetAlpha( stoneglow, SDL_SRCALPHA, 0 );
			apply_surface( x - 5 - camera.x, y - 8 - camera.y, stoneglow, screen, &GlowClips[5] );

			if( GlowStrength - 48 >= 0 ) SDL_SetAlpha( stoneglow, SDL_SRCALPHA, GlowStrength - 48 ); else SDL_SetAlpha( stoneglow, SDL_SRCALPHA, 0 );
			apply_surface( x - 5 - camera.x, y - 8 - camera.y, stoneglow, screen, &GlowClips[4] );

			SDL_SetAlpha( stoneglow, SDL_SRCALPHA, GlowStrength );
			apply_surface( x - 5 - camera.x, y - 8 - camera.y, stoneglow, screen, &GlowClips[3] );

			GlowStrength += GlowVel;			

			if( GlowStrength < 15 ) GlowVel = 8;
			if( GlowStrength > 160 ) GlowVel = -8;
		}
		else
		{
			if( GlowStrength - 96 >= 0 ) SDL_SetAlpha( stoneglow, SDL_SRCALPHA, GlowStrength - 96 ); else SDL_SetAlpha( stoneglow, SDL_SRCALPHA, 0 );
			apply_surface( x - 5 - camera.x, y - 5 - camera.y, stoneglow, screen, &GlowClips[2] );

			if( GlowStrength - 48 >= 0 ) SDL_SetAlpha( stoneglow, SDL_SRCALPHA, GlowStrength - 48 ); else SDL_SetAlpha( stoneglow, SDL_SRCALPHA, 0 );
			apply_surface( x - 5 - camera.x, y - 5 - camera.y, stoneglow, screen, &GlowClips[1] );

			SDL_SetAlpha( stoneglow, SDL_SRCALPHA, GlowStrength );
			apply_surface( x - 5 - camera.x, y - 5 - camera.y, stoneglow, screen, &GlowClips[0] );

			GlowStrength += GlowVel;			

			if( GlowStrength < 15 ) GlowVel = 4;
			if( GlowStrength > 160 ) GlowVel = -4;
		}

		apply_surface( x - camera.x, y - camera.y, stonepic, screen );
	}

	//make some particles around yourself. 
	//gargpuffs. when you descend, you make them around yourself, they going down 1px/f.
	//when you're not moving though... they go out from you at rand() % 2
	//create particles at random intervals
	if( !justaparticle && moving && !(rand() % 3)  )
	{
		//where should it go? Perimeter would be ok. Want some inside as well.
		//anywhere between x and x+32, y and y+32
		//taking only the lower edges of the inside parts, the perimeter is 192.
		gargpuffcursor = rand() % 5;

		if( gargpuffcursor % 5 == 0 ) gargpuffs[ gargpuffcursor ]->relocate( x + 16, y - 6, 9, 0 );
		if( gargpuffcursor % 5 == 1 ) gargpuffs[ gargpuffcursor ]->relocate( x + 12, y - 3, 9, 0 );
		if( gargpuffcursor % 5 == 2 ) gargpuffs[ gargpuffcursor ]->relocate( x + 8, y - 0, 9, 0 );
		if( gargpuffcursor % 5 == 3 ) gargpuffs[ gargpuffcursor ]->relocate( x + 20, y - 3, 9, 0 );
		if( gargpuffcursor % 5 == 4 ) gargpuffs[ gargpuffcursor ]->relocate( x + 24, y - 0, 9, 0 );
	}
}


int stone::get_x()
{
	//if you're not here, you're in the top left corner. So no levels are permitted to allow beads there.
	if( !on ) return 0;

	return x;
}
int stone::get_y()
{
	//if you're not here, you're in the top left corner. So no levels are permitted to allow beads there.
	if( !on ) return 0;

	return y;
}

bool stone::ismoving()
{
	return moving;
}
angel::angel( int Ecks, int Whyy, bool sera )
{
	x = Ecks;
	y = Whyy;

	seraphim = sera;

	thought = 0;

	offset = rand() % 20;

	//when an angel is created for the first time, i.e. the game begins, we don't confuse the player with the animation.
	if( level != 1 ) rejuvenated = 1;
	else rejuvenated = 0;

	//initialize this to a bullshit value coz no particular real one makes sense
	apparentdirection = 0;

	//if it's a null angel, make sure no other functions get called.
	if( x == 0 && y == 0 ) on = 0;
	else on = 1;

	//random number to see what the gender is
	if( rand() > 16,000 ) male = 1;
}

void angel::show( stone *stones[], int frame )
{
	if( !on ) return;

	//first, do we need to play the rejuvenation animation? Ironically we play the animation if rejuvenated is NOT equal to zero.
	//only do anything if you're onscreen, otherwise never mind.
	if( rejuvenated )
	{
		//Play sound. Funny how there's probably a more efficient place to do this but it's more sincere if the sound's coming from this function
		if( rejuvenated == 2 ) Mix_PlayChannel( 2, laaa, 0 );

		if( rejuvenated == 10 ) shake = 12;

		//this is the release animation played backward.
		apply_surface( x - camera.x - 5, y - camera.y, angelrelease, screen, &vanishclips[ 13 - rejuvenated ] );

		//move animation on
		rejuvenated++;

		//if it's ended make it false
		if( rejuvenated == 13 ) rejuvenated = 0;

		return;
	}

	//go through the stones
	for( int i = 0; i < TOTAL_STONES; i++ )
	{
		//if there's a stone above you
		if(	y + 4 * TILE_HEIGHT == stones[ i ]->get_y() + 8 * TILE_WIDTH

			 //angel.x + 9 tiles == stone.x would mean folding the left wing in
			 && stones[ i ]->get_x() < x + 9 * TILE_WIDTH

			 //angel.x + 6 tiles == stone.x + 8 would mean folding the right wing in
			 && x + 6 * TILE_WIDTH < stones[ i ]->get_x() + 8 * TILE_WIDTH
		   )
		{
			//there's a stone on you
			if( seraphim ) apply_surface( x - camera.x + 16, y - camera.y + 16, redAngel_bearing, screen, &floatingclips[ ( frame % 20 ) / 5 ]  );

			//make a sound?
			thought = 0;
			return;
		}

		//if there's a stone covering your wings
		if(	y + 4 * TILE_HEIGHT < stones[ i ]->get_y() + 8 * TILE_WIDTH && y + 11 * TILE_HEIGHT > stones[ i ]->get_y() )
		{
			if(
				//if it's completely covering the right wing
				x + 9 * TILE_WIDTH == stones[ i ]->get_x()

				//or partially covering it. Or rather covering the middle of it, corners are ok
				|| ( x + 10 * TILE_WIDTH == stones[ i ]->get_x() && stones[ i ]->get_y() < y + 10 * TILE_HEIGHT )
				)
			{
				apply_surface( x - camera.x + 16, y - camera.y + 16, rightfolded, screen );

				thought = 0;
				return;
			}

			if(
				//if it's completely covering the left wing
				x - 2 * TILE_WIDTH == stones[ i ]->get_x()

				//or partially covering it
				|| x - 3 * TILE_WIDTH == stones[ i ]->get_x() )
			{
				apply_surface( x - camera.x + 16, y - camera.y + 16, leftfolded, screen );

				thought = 0;
				return;
			}
		}
	}

	//If the angel wants to get through something solid they should be flying

	//if apparentdirection isn't zero, fly in the direction you're going or in which you last went
	if( apparentdirection == 1 )
	{
		//down
		apply_surface( x - camera.x + 16, y - camera.y + 16, moving, screen, &flyingdownclips[ ( frame % 24 ) / 4 ]  );

		thought = 0;
		return;
	}
	if( apparentdirection == 2 )
	{
		apply_surface( x - camera.x + 16, y - camera.y + 16, moving, screen, &flyingdownleftclips[ ( frame % 24 ) / 4 ]  );

		thought = 0;
		return;
	}
	if( apparentdirection == 3 )
	{
		apply_surface( x - camera.x + 16, y - camera.y + 16, moving, screen, &flyingleftclips[ ( frame % 24 ) / 4 ]  );

		thought = 0;
		return;
	}
	if( apparentdirection == 4 )
	{
		apply_surface( x - camera.x + 16, y - camera.y + 16, moving, screen, &flyingupleftclips[ ( frame % 24 ) / 4 ]  );

		thought = 0;
		return;
	}
	if( apparentdirection == 5 )
	{
		apply_surface( x - camera.x + 16, y - camera.y + 16, moving, screen, &flyingupclips[ ( frame % 24 ) / 4 ]  );

		thought = 0;
		return;
	}
	if( apparentdirection == 6 )
	{
		apply_surface( x - camera.x + 16, y - camera.y + 16, moving, screen, &flyinguprightclips[ ( frame % 24 ) / 4 ]  );

		thought = 0;
		return;
	}
	if( apparentdirection == 7 )
	{
		apply_surface( x - camera.x + 16, y - camera.y + 16, moving, screen, &flyingrightclips[ ( frame % 24 ) / 4 ]  );

		thought = 0;
		return;
	}
	if( apparentdirection == 8 )
	{
		apply_surface( x - camera.x + 16, y - camera.y + 16, moving, screen, &flyingdownrightclips[ ( frame % 24 ) / 4 ]  );

		thought = 0;
		return;
	}

	//apply the seraphim or praying pic
	if( seraphim ) apply_surface( x - camera.x + 15, y - camera.y + 16, redAngel, screen, &floatingclips[ ( (frame+offset) % 20 ) / 5 ] ); //You could add a random 0-20 number to frame
	
	thought = 0;
}



void angel::check( int future, Bead *beads[], Tile *tiles[], stone *stones[], angel *angels[] )
{
	if( !on ) return;

	//the options. Looking at the beads' position will eliminate several of these, and walls will eliminate more. Being TRUE means they ARE possible.
	//lowest bit to highest: down, rightdown, right, upright, up, upleft, left, downleft. We turn them all on at the beginning of the frame and then we turn them off if need be.
	options = 255;

	for( int i = 0; i < TOTAL_BEADS; i++ )
	{
		//we store the current properties of the bead
		int dyrr = beads[i]->dir;
		int ecks = beads[i]->x;
		int whyy = beads[i]->y;

		
		//move them the right amount into the future that we want
		for( int f = 0; f < future; f++ )
		{
			beads[i]->move( 1, tiles, stones, angels );
		}

		//the relative positions
		int z = beads[i]->x - x;
		int j = beads[i]->y - y;

		//used to think about immediate bounces
		int presentfuturedyrr = beads[i]->dir;

		//did a bullet hit us in our predictions?
		bool ITHITUS = 0;

		//this part should actually be AFTER we've seen if the bullet is scary.

		//it's definitely something about stalling, since you did that experiment. The stall somehow negate


		//move it a bit more into the future to see if it's about to bounce. The number of these is rather arbitrary.
		//these will return true if they hit AN angel. NOTE that doesn't necessarily mean they hit YOU, so a funny thing will happen if there's an angel making another angel safe.
		if( beads[i]->move( 1, tiles, stones, angels ) ) ITHITUS = 1;
		if( !ITHITUS && presentfuturedyrr != beads[i]->dir )
		{
			beads[i]->change( ecks, whyy, dyrr );
			continue;
		}
		if( beads[i]->move( 1, tiles, stones, angels ) ) ITHITUS = 1;
		if( !ITHITUS && presentfuturedyrr != beads[i]->dir )
		{
			beads[i]->change( ecks, whyy, dyrr );
			continue;
		}
		if( beads[i]->move( 1, tiles, stones, angels ) ) ITHITUS = 1;
		if( !ITHITUS && presentfuturedyrr != beads[i]->dir )
		{
			beads[i]->change( ecks, whyy, dyrr );
			continue;
		}
		if( beads[i]->move( 1, tiles, stones, angels ) ) ITHITUS = 1;
		if( !ITHITUS && presentfuturedyrr != beads[i]->dir )
		{
			beads[i]->change( ecks, whyy, dyrr );
			continue;
		}
		if( beads[i]->move( 1, tiles, stones, angels ) ) ITHITUS = 1;

		//if our bead is about to change direction, don't worry about it. Unless its direction change is caused by an angel dying
		if( !ITHITUS && presentfuturedyrr != beads[i]->dir )
		{
			beads[i]->change( ecks, whyy, dyrr );
			continue;
		}

		//you might have changed something when you switched around the above.

		//mkay now we must put it back
		beads[i]->change( ecks, whyy, dyrr );

		//is there a bead anywhere near you? If so, you need to work out what it means
		if( z >= 0 && z <= 60 && 0 <= j && j <= 60
			&& ( ( 16 <= j && j <= 44 ) || ( 16 <= z && z <= 44 ) )
			)
		{

			//these are used to work out where in the star you are.
			int a = z + j;
			int b = z - j;

			//surely you have to reset nonant each time? Nonant is left to right, top to bottom.
			int nonant = 0;

			//get the nonant
			if( z < 20 )	nonant = 1;
			else
			if( z < 44 )	nonant = 2;
			else			nonant = 3;

			if( j > 16 )	nonant += 3;
			if( j > 40 )	nonant += 3;

			switch( nonant )
			{
				//the corners
				case 1:
				if( z == 16 || j == 16 )
				{
					//top left sausage
					if( beads[i]->dir == 7 )													options = options & 143;
				} break;

				case 3:
				if( z == 44 || j == 16 )
				{
					//top right sausage
					if( beads[i]->dir == 1 )													options = options & 227;
				} break;

				case 7:
				if( z == 16 || j == 44 )
				{
					//bottom left sausage
					if( beads[i]->dir == 5 )													options = options & 62;

				} break;

				case 9:
				if( z == 44 || j == 44 )
				{
					//bottom right sausage
					if( beads[i]->dir == 3 )													options = options & 248;
				} break;

				//holes, triangles, braces, in that order because there are common elements. speedup opportunity: squash the top holes and those bits of the triangles together.
				case 2:
				{
					if( j == 16 && (z == 28 || z == 32) )
					{
						//top holes
						if( beads[i]->dir == 0 || beads[i]->dir == 7 || beads[i]->dir == 1 )	options = options & 131;
					}					
					else
					if( b < 20 )
					{
						//11 o' clock triangle
						if( beads[i]->dir == 0 )												options = options & 135;
						else
						if( beads[i]->dir == 7 )												options = options & 131;
					}
					else
					if( a > 40 )
					{
						//1 o' clock triangle
						if( beads[i]->dir == 0 )												options = options & 195;
						else
						if( beads[i]->dir == 1 )												options = options & 131;
					}
					else
					if( a == 40 || b == 20 )
					{
						//top sausage
						if( beads[i]->dir == 0 )												options = options & 199;
					}
				} break;

				case 4:
				{
					if( z == 16 && (j == 28 || j == 32) )
					{
						//left holes
						if( beads[i]->dir == 5 || beads[i]->dir == 6 || beads[i]->dir == 7 )	options = options & 14;					
					}
					if( a > 40 )
					{
						//8 o' clock triangle
						if( beads[i]->dir == 6 )												options = options & 30;
						else
						if( beads[i]->dir == 5 )												options = options & 14;
					}
					else
					if( b > -20 )
					{
						//10 o' clock triangle
						if( beads[i]->dir == 6 )												options = options & 15;
						else
						if( beads[i]->dir == 7 )												options = options & 14;
					}
					else
					if( a == 40 || b == -20 )
					{
						//left sausage
						if( beads[i]->dir == 6 )												options = options & 31;
					}
				} break;

				case 6:
				{
					if( z == 44 && (j == 28 || j == 32) )
					{
						//right holes
						if( beads[i]->dir == 1 || beads[i]->dir == 2 || beads[i]->dir == 3 )	options = options & 224;
					}
					else
					if( a < 80 )
					{
						//2 o' clock triangle
						if( beads[i]->dir == 2 )												options = options & 225;
						else
						if( beads[i]->dir == 1 )												options = options & 224;
					}
					else
					if( b < 20 )
					{
						//4 o' clock triangle
						if( beads[i]->dir == 2 )												options = options & 240;
						else
						if( beads[i]->dir == 3 )												options = options & 224;
					}
					else
					if( a == 80 || b == 20 )
					{
						//right sausage
						if( beads[i]->dir == 2 )												options = options & 241;
					}
				} break;

				case 8:
				{
					if( (z == 28 || z == 32) && j == 44 )
					{
						//bottom holes
						if( beads[i]->dir == 3 || beads[i]->dir == 4 || beads[i]->dir == 5 )	options = options & 56;
					}
					else
					if( b > -20 )
					{
						//5 o' clock triangle
						if( beads[i]->dir == 4 )												options = options & 120;
						else
						if( beads[i]->dir == 3 )												options = options & 56;
					}
					else
					if( a < 80 )
					{
						//7 o' clock triangle
						if( beads[i]->dir == 4 )												options = options & 60;
						else
						if( beads[i]->dir == 5 )												options = options & 56;
					}
					else
					if( a == 80 || b == -20 )
					{
						//bottom sausage
						if( beads[i]->dir == 4 )												options = options & 124;
					}
				} break;

				//the niches
				case 5:
				{
					if( j == 20 )
					{
						if( z == 20 )
						{
							//top left niche
							if( beads[i]->dir == 7 )											options = options & 2;
							if( beads[i]->dir == 0 || beads[i]->dir == 6 )						options = options & 7;
						}
						if( z == 40 )
						{
							//top right niche
							if( beads[i]->dir == 1 )											options = options & 128;
							if( beads[i]->dir == 0 || beads[i]->dir == 2 )						options = options & 193;
						}
					}
					if( j == 40 )
					{
						if( z == 20 )
						{
							//bottom left niche
							if( beads[i]->dir == 5 )											options = options & 8;
							if( beads[i]->dir == 4 || beads[i]->dir == 6 )						options = options & 28;
						}
						if( z == 40 )
						{
							//bottom right niche
							if( beads[i]->dir == 3 )											options = options & 32;
							if( beads[i]->dir == 2 || beads[i]->dir == 4 )						options = options & 112;
						}
					}
				} break;
			}			
		}
	}
	return;
}

void angel::think( Tile *tiles[], stone *stones[], Bead *beads[], angel *angels[] )
{
	//if the angel doesn't really exist, or if this function has already been called this frame
	if( !on || thought ) return;

	//well, now the angel's done its thinking
	thought = 1;


	//only look as though you flew if you flew


	//if there were no beads to be worried about, then there's deffo no move this turn.
	if( options == 255 ) { apparentdirection = 0; return; }

	//these shall be used to store the emergency movement, which shall be resorted to if all others fail. Being 0 means nothing's happened to them
	int emergencyX = 0;
	int emergencyY = 0;

	//where you are in relation to the avatar
	unsigned char octant = 0;

	//avatar.x+7 = camera.x+199,     avatar.y+14 = (camera.y+118)

	//OPTION: change the <s to =< or something, if there is a puzzle that would like it. This governs what the angel will do if it is on a diagonal boundary.
	//the priority of directions is determined by the octant you're in.
	if( (x+30) < (camera.x+200) ) //it's to the left
	{
		if( (y+30) < (camera.y+120) ) //it's above
		{
			if( (y+30) - (camera.y+120) > (x+30) - (camera.x+200) ) //it's at the 10 o'clock slice
				 octant = 8;
			else octant = 1; //it's at the 11 o'clock slice
		}
		else //below
		{
			if( (y+30) - (camera.y+120) > (camera.x+200) - (x+30) ) //it's at the 7 o'clock slice
				 octant = 6;
			else octant =  7; //it's at the 8 o'clock slice
		}
	}
	else //it's to the right
	{
		if( y+30 < (camera.y+120) ) //it's above
		{
			if( (y+30) - (camera.y+120) < (camera.x+200) - (x+30) ) //it's at the 2 o'clock slice
				 octant = 2;
			else octant = 3; //it's at the 1 o'clock slice
		}
		else //below
		{			
			if( (y+30) - (camera.y+120) > (x+30) - (camera.x+200) ) //it's at the 5 o'clock slice
				 octant = 5;
			else octant = 4; //it's at the 4 o'clock slice
		}
	}

	if( octant == 1 ) //11 o'clock slice
	{
		//so downright is best
		if( options & 2 )
		{
			//try the direction. If move is successful (true) then dodge has happened. It may also change emergencyX and Y.
			if( move( 8, tiles, stones, beads, angels, &emergencyX, &emergencyY ) ) return;
		}
		
		//down
		if( options & 1 )
		{
			if( move( 1, tiles, stones, beads, angels, &emergencyX, &emergencyY ) ) return;
		}
		
		//downleft
		if( options & 128 )
		{
			if( move( 2, tiles, stones, beads, angels, &emergencyX, &emergencyY ) ) return;
		}
		
		//right
		if( options & 4 )
		{
			if( move( 7, tiles, stones, beads, angels, &emergencyX, &emergencyY ) ) return;
		}
		
		//left
		if( options & 64 )
		{
			if( move( 3, tiles, stones, beads, angels, &emergencyX, &emergencyY ) ) return;
		}
		
		//upright
		if( options & 8 )
		{
			if( move( 6, tiles, stones, beads, angels, &emergencyX, &emergencyY ) ) return;
		}
		
		//up
		if( options & 16 )
		{
			if( move( 5, tiles, stones, beads, angels, &emergencyX, &emergencyY ) ) return;
		}
		
		//upleft
		if( options & 32 )
		{
			if( move( 4, tiles, stones, beads, angels, &emergencyX, &emergencyY ) ) return;
		}

		//Nowhere to go! In desperation, go somewhere that may not have a future, if such a place has been suggested
		if( emergencyX != 0 )
		{
			x = emergencyX;
			y = emergencyY;
		}
		return;
	}

	if( octant == 2 ) //1 o'clock slice
	{
		//so downleft is best
		if( options & 128 )
		{
			if( move( 2, tiles, stones, beads, angels, &emergencyX, &emergencyY ) ) return;
		}

		//down. It actually thinks this is a good idea!

		//this is a good idea!
		if( options & 1 )
		{			
			if( move( 1, tiles, stones, beads, angels, &emergencyX, &emergencyY ) ) return;			
		}

		//downright
		if( options & 2 )
		{
			if( move( 8, tiles, stones, beads, angels, &emergencyX, &emergencyY ) ) return;
		}		

		//left
		if( options & 64 )
		{
			if( move( 3, tiles, stones, beads, angels, &emergencyX, &emergencyY ) ) return;
		}

		//right
		if( options & 4 )
		{
			if( move( 7, tiles, stones, beads, angels, &emergencyX, &emergencyY ) ) return;
		}

		//upleft
		if( options & 32 )
		{
			if( move( 4, tiles, stones, beads, angels, &emergencyX, &emergencyY ) ) return;
		}
		

		//up
		if( options & 16 )
		{
			if( move( 5, tiles, stones, beads, angels, &emergencyX, &emergencyY ) ) return;
			
		}

		//upright
		if( options & 8 )
		{
			if( move( 6, tiles, stones, beads, angels, &emergencyX, &emergencyY ) ) return;
		}

		//she is going up, then down.

		if( emergencyX != 0 )
		{
			
			x = emergencyX;
			y = emergencyY;

		}
		return;
	}

	//it's all in here.
	if( octant == 3 ) //2 o'clock slice
	{		
		//downleft
		if( options & 128 )
		{
			if( move( 2, tiles, stones, beads, angels, &emergencyX, &emergencyY ) ) return;
		}

		//left
		if( options & 64 )
		{
			if( move( 3, tiles, stones, beads, angels, &emergencyX, &emergencyY ) ) return;
		}

		//upleft
		if( options & 32 )
		{
			if( move( 4, tiles, stones, beads, angels, &emergencyX, &emergencyY ) ) return;
		}

		//down
		if( options & 1 )
		{
			if( move( 1, tiles, stones, beads, angels, &emergencyX, &emergencyY ) ) return;
		}

		//somewhere between here
		//up
		if( options & 16 )
		{
			if( move( 5, tiles, stones, beads, angels, &emergencyX, &emergencyY ) ) return;
		}

		//downright
		if( options & 2 )
		{ 
			if( move( 8, tiles, stones, beads, angels, &emergencyX, &emergencyY ) ) return;
		}

		//right
		if( options & 4 )
		{
			if( move( 7, tiles, stones, beads, angels, &emergencyX, &emergencyY ) ) return;
		}

		//upright
		if( options & 8 )
		{
			if( move( 6, tiles, stones, beads, angels, &emergencyX, &emergencyY ) ) return;
		}

		if( emergencyX != 0 )
		{
			x = emergencyX;
			y = emergencyY;
		}
		return;
	}

	if( octant == 4 ) //4 o'clock slice
	{		
		//upleft
		if( options & 32 )
		{
			if( move( 4, tiles, stones, beads, angels, &emergencyX, &emergencyY ) ) return;
		}


		//left
		if( options & 64 )
		{
			if( move( 3, tiles, stones, beads, angels, &emergencyX, &emergencyY ) ) return;
		}

		//downleft
		if( options & 128 )
		{
			if( move( 2, tiles, stones, beads, angels, &emergencyX, &emergencyY ) ) return;
		}
		
		//up
		if( options & 16 )
		{
			if( move( 5, tiles, stones, beads, angels, &emergencyX, &emergencyY ) ) return;
		}

		//down
		if( options & 1 )
		{
			if( move( 1, tiles, stones, beads, angels, &emergencyX, &emergencyY ) ) return;
		}

		//upright
		if( options & 8 )
		{
			if( move( 6, tiles, stones, beads, angels, &emergencyX, &emergencyY ) ) return;
		}

		//right
		if( options & 4 )
		{
			if( move( 7, tiles, stones, beads, angels, &emergencyX, &emergencyY ) ) return;
		}

		//downright
		if( options & 2 )
		{
			if( move( 8, tiles, stones, beads, angels, &emergencyX, &emergencyY ) ) return;
		}

		if( emergencyX != 0 )
		{
			x = emergencyX;
			y = emergencyY;
		}
		return;
	}

	if( octant == 5 ) //5 o'clock slice
	{		
		//upleft
		if( options & 32 )
		{
			if( move( 4, tiles, stones, beads, angels, &emergencyX, &emergencyY ) ) return;
		}

		//up
		if( options & 16 )
		{
			if( move( 5, tiles, stones, beads, angels, &emergencyX, &emergencyY ) ) return;
		}

		//upright
		if( options & 8 )
		{
			if( move( 6, tiles, stones, beads, angels, &emergencyX, &emergencyY ) ) return;
		}

		//left
		if( options & 64 )
		{
			if( move( 3, tiles, stones, beads, angels, &emergencyX, &emergencyY ) ) return;
		}	

		//right
		if( options & 4 )
		{
			if( move( 7, tiles, stones, beads, angels, &emergencyX, &emergencyY ) ) return;
		}

		//downleft
		if( options & 128 )
		{
			if( move( 2, tiles, stones, beads, angels, &emergencyX, &emergencyY ) ) return;
		}
		
		//down
		if( options & 1 )
		{
			if( move( 1, tiles, stones, beads, angels, &emergencyX, &emergencyY ) ) return;
		}

		//downright
		if( options & 2 )
		{
			if( move( 8, tiles, stones, beads, angels, &emergencyX, &emergencyY ) ) return;
		}

		if( emergencyX != 0 )
		{
			x = emergencyX;
			y = emergencyY;			
		}
		return;
	}

	if( octant == 6 ) //7 o'clock slice
	{		
		//upright
		if( options & 8 )
		{
			if( move( 6, tiles, stones, beads, angels, &emergencyX, &emergencyY ) ) return;
		}
		
		//up
		if( options & 16 )
		{
			if( move( 5, tiles, stones, beads, angels, &emergencyX, &emergencyY ) ) return;
		}
		
		//upleft
		if( options & 32 )
		{
			if( move( 4, tiles, stones, beads, angels, &emergencyX, &emergencyY ) ) return;
		}

		//right
		if( options & 4 )
		{
			if( move( 7, tiles, stones, beads, angels, &emergencyX, &emergencyY ) ) return;
		}

		//left
		if( options & 64 )
		{
			if( move( 3, tiles, stones, beads, angels, &emergencyX, &emergencyY ) ) return;
		}

		//downright
		if( options & 2 )
		{
			if( move( 8, tiles, stones, beads, angels, &emergencyX, &emergencyY ) ) return;
		}

		//down
		if( options & 1 )
		{
			if( move( 1, tiles, stones, beads, angels, &emergencyX, &emergencyY ) ) return;
		}

		//downleft
		if( options & 128 )
		{
			if( move( 2, tiles, stones, beads, angels, &emergencyX, &emergencyY ) ) return;
		}

		if( emergencyX != 0 )
		{
			x = emergencyX;
			y = emergencyY;			
		}
		return;
	}

	if( octant == 7 ) //8 o'clock slice
	{
		//upright
		if( options & 8 )
		{
			if( move( 6, tiles, stones, beads, angels, &emergencyX, &emergencyY ) ) return;
		}

		//right
		if( options & 4 )
		{
			if( move( 7, tiles, stones, beads, angels, &emergencyX, &emergencyY ) ) return;
		}
		
		//downright
		if( options & 2 )
		{
			if( move( 8, tiles, stones, beads, angels, &emergencyX, &emergencyY ) ) return;
		}
		
		//up
		if( options & 16 )
		{
			if( move( 5, tiles, stones, beads, angels, &emergencyX, &emergencyY ) ) return;
		}
		
		//down
		if( options & 1 )
		{
			if( move( 1, tiles, stones, beads, angels, &emergencyX, &emergencyY ) ) return;
		}		
		
		//upleft
		if( options & 32 )
		{
			if( move( 4, tiles, stones, beads, angels, &emergencyX, &emergencyY ) ) return;
		}

		//left
		if( options & 64 )
		{
			if( move( 3, tiles, stones, beads, angels, &emergencyX, &emergencyY ) ) return;
		}		

		//downleft
		if( options & 128 )
		{
			if( move( 2, tiles, stones, beads, angels, &emergencyX, &emergencyY ) ) return;
		}

		if( emergencyX != 0 )
		{
			x = emergencyX;
			y = emergencyY;
		}
		return;
	}

	if( octant == 8 ) //10 o'clock slice
	{
		//downright
		if( options & 2 )
		{
			if( move( 8, tiles, stones, beads, angels, &emergencyX, &emergencyY ) ) return;
		}

		//right
		if( options & 4 )
		{
			if( move( 7, tiles, stones, beads, angels, &emergencyX, &emergencyY ) ) return;
		}

		//upright
		if( options & 8 )
		{
			if( move( 6, tiles, stones, beads, angels, &emergencyX, &emergencyY ) ) return;
		}

		//down
		if( options & 1 )
		{
			if( move( 1, tiles, stones, beads, angels, &emergencyX, &emergencyY ) ) return;
		}
						
		//up
		if( options & 16 )
		{
			if( move( 5, tiles, stones, beads, angels, &emergencyX, &emergencyY ) ) return;
		}

		//downleft
		if( options & 128 )
		{
			if( move( 2, tiles, stones, beads, angels, &emergencyX, &emergencyY ) ) return;
		}

		//left
		if( options & 64 )
		{
			if( move( 3, tiles, stones, beads, angels, &emergencyX, &emergencyY ) ) return;
		}
						
		//upleft
		if( options & 32 )
		{
			if( move( 4, tiles, stones, beads, angels, &emergencyX, &emergencyY ) ) return;
		}		

		if( emergencyX != 0 )
		{
			x = emergencyX;
			y = emergencyY;
		}
		return;
	}

	//etc
	return;
}

//takes the direction that the angel wants to go in, moves it. Returns true if movement is fine. If it's not, angel is moved back, and return value is false.
//arrows are pointing in, start at the top, number them clockwise.
//note: don't expect her to deal well with the edges of levels
//needs to take in beads too, otherwise it's confusing for the player, who isn't so aware of the "coming at me/not coming at me" distinction when it comes to movement. Shit this is hard though.
bool angel::move( int dir, Tile *tiles[], stone *stones[], Bead *beads[], angel *angels[], int *emergencyX, int *emergencyY )
{	
	//will be either 0, 1, or -1
	int xVel = 0;
	int yVel = 0;

	//assign the things based on the direction we want to go
	if( dir == 1 ) { yVel = 1; }
	if( dir == 2 ) { yVel = 1; xVel = -1; }
	if( dir == 3 ) { xVel = -1; }
	if( dir == 4 ) { yVel = -1; xVel = -1; }
	if( dir == 5 ) { yVel = -1; }
	if( dir == 6 ) { yVel = -1; xVel = 1; }
	if( dir == 7 ) { xVel = 1; }
	if( dir == 8 ) { yVel = 1; xVel = 1; }

	//store the old co ords
	int originalX = x;
	int originalY = y;
	


	//have a look into the future. This was 11 until you tuned for the one where an angel must be positioned to catch a garg
	//you can change it if you must. Putting it up will break that level, but taking it down may be ok.
	for( int future = 1; future < 10; future++ )
	{ 
		//modify x and y the appropriate amount. This is taking you in a straight line.
		x += TILE_WIDTH * xVel;
		y += TILE_HEIGHT * yVel;

		//check for reasons to retract. Does collisions catch bullets we shouldn't worry about?
		if( collisions( tiles, stones, beads, angels ) )
		{
			//this direction is either unproductive or immediately obstructed. Return to where you were
			x = originalX;
			y = originalY;


			//if this is a future prediction then this movement is bad, but the stem may still be your best bet, unless another move() has already done something with them
			if( future != 1 && *emergencyX == 0 && *emergencyY == 0 )
			{	
				*emergencyX = originalX + TILE_WIDTH * xVel;
				*emergencyY = originalY + TILE_HEIGHT * yVel;



				//strange potential?
				apparentdirection = dir;
			}

			//given that we've gone into the future, we must've fiddled around with options.
			check( 0, beads, tiles, stones, angels );

			//this direction is not ideal
			
			return 0;
		}

		//It's fine to be here. Are you also safe?
		check( future, beads, tiles, stones, angels ); //you need to change options back...

		if( options == 255 )
		{
			//are you absolutely sure you're safe? You haven't just moved the bullet into one of your grooves?
			check( future + 2, beads, tiles, stones, angels );

			//if there's still nothing there then you're in the clear!
			if( options == 255 )
			{
				//there's a possibility of safety somewhere in the future, so this general movement is ok.
				x = originalX + TILE_WIDTH * xVel;
				y = originalY + TILE_HEIGHT * yVel;

				//we've actually gone in this direction
				apparentdirection = dir; 

				

				return 1;
			}		
		}
		
		//if it didn't make you safe, we try another move.
	}

	//you looked 10 moves ahead and you didn't escape? (or die?) That means this direction is a chase. That's not ideal but it may be making the best of a bad situation.
	//certainly it's making a better thing of a bad situation than crashing into something. Therfore... change emergencies even if they alread have a value?
	x = originalX;
	y = originalY;

	//it's that thing where one forces the other to do its think, but it's doing it again. It's coz you've got too many checks.

	*emergencyX = originalX + TILE_WIDTH * xVel;
	*emergencyY = originalY + TILE_HEIGHT * yVel;

	//strange potential?
	apparentdirection = dir;

	//given that we've gone into the future, we must've fiddled around with options.
	check( 0, beads, tiles, stones, angels );

	
	return 0;
}

bool angel::collisions( Tile *tiles[], stone *stones[], Bead *beads[], angel *angels[] )
{
	//check the gargoyles
	for( int g = 0; g < TOTAL_STONES; g++ )
	{
		//if the angel is inside. It is allowed its wings in.
		if(    y+4*TILE_HEIGHT < stones[ g ]->get_y() + 8 * TILE_HEIGHT && y+11*TILE_HEIGHT > stones[ g ]->get_y()
			&& x+6*TILE_HEIGHT < stones[ g ]->get_x() + 8 * TILE_HEIGHT && x+9*TILE_HEIGHT > stones[ g ]->get_x() )
		{
			//you're in a garg, get out
			return 1;
		}
	}

	//and angels. Uh, don't include yourself...
	for( int a = 0; a < TOTAL_ANGELS; a++ )
	{
		int relativeX = angels[ a ]->get_x() - x;
		int relativeY = angels[ a ]->get_y() - y;

		//if the angel is inside.
		if(    -7 * TILE_HEIGHT < relativeY && relativeY < 7 * TILE_HEIGHT
			&& -7 * TILE_WIDTH < relativeX && relativeX < 7 * TILE_WIDTH
			&& !( relativeX == 0 && relativeY == 0 ) //make sure you don't test with yourself...
			)
		{
			//If it's in any of the corners, never mind.
			if(    relativeX + relativeY < -9 * TILE_WIDTH //if it's in the top left corner
				|| relativeX + relativeY > 9 * TILE_WIDTH  //bottom right
				|| relativeY > relativeX + 9 * TILE_WIDTH  //bottom left
				|| relativeY < relativeX - 9 * TILE_WIDTH  //top right						
				) continue;

			//otherwise you're in an angel
			//it may be about to move anyway
			angels[ a ]->think( tiles, stones, beads, angels );

			//so you need to do the check again. variables:

			relativeX = angels[ a ]->get_x() - x;
			relativeY = angels[ a ]->get_y() - y;

			//box
			if(    -7 * TILE_HEIGHT < relativeY && relativeY < 7 * TILE_HEIGHT
			&& -7 * TILE_WIDTH < relativeX && relativeX < 7 * TILE_WIDTH
			&& !( relativeX == 0 && relativeY == 0 ) //make sure you don't test with yourself...
			)
			{
				//corners
				if(    relativeX + relativeY < -9 * TILE_WIDTH //if it's in the top left corner
					|| relativeX + relativeY > 9 * TILE_WIDTH  //bottom right
					|| relativeY > relativeX + 9 * TILE_WIDTH  //bottom left
					|| relativeY < relativeX - 9 * TILE_WIDTH  //top right						
					) continue;

				//it's settled then - there's an angel around and there's nothing to be done about it.
				return 1;
			}
		}
	}

	//some beads have not yet been taken into account.
	for( int i = 0; i < TOTAL_BEADS; i++ )			
	{
		int z = beads[i]->x - x;
		int j = beads[i]->y - y;

		//if you're in the bounds
		if(    12 < z && z < 48 && 12 < j && j < 48 //square
			&& 36 < j + z && j + z < 84
			&& -24 < j - z && j - z < 24 //diagonal pipes
			)
		{
			//make the variables into what they shall be after the bullet's next move					
			if( beads[i]->dir == 0 ) { j += TILE_HEIGHT; }
			else
			if( beads[i]->dir == 1 ) { z += -TILE_WIDTH; j += TILE_HEIGHT; }
			else
			if( beads[i]->dir == 2 ) { z += -TILE_WIDTH; }
			else
			if( beads[i]->dir == 3 ) { z += -TILE_WIDTH; j += -TILE_HEIGHT; }
			else
			if( beads[i]->dir == 4 ) { j += -TILE_HEIGHT; }
			else
			if( beads[i]->dir == 5 ) { z += TILE_WIDTH; j += -TILE_HEIGHT; }
			else
			if( beads[i]->dir == 6 ) { z += TILE_WIDTH; }
			else
			if( beads[i]->dir == 7 ) { z += TILE_WIDTH; j += TILE_HEIGHT; }

			//if the bead's in there
			if(    16 < z && z < 44 && 16 < j && j < 44
				&& 40 < j + z && j + z < 80
				&& -20 < j - z && j - z < 20
				)
			{
				//then this is a dangerous bead
				return 1;
			}
			//the bead is going to escape - we needn't worry.
		}
		//the bead wasn't in the bounds
	}

	//the position of the tile in the top left corner of the angel
	int t = furlong * (y+16) / TILE_WIDTH + (x+16) / TILE_WIDTH;

	//go through the necessary tiles inside the angel
	for( int r = 0; r < 7; r++ )
	{
		//go through the columns
		for( int c = 0; c < 7; c++ )
		{
			//don't worry about the corners
			if(	(r == 0 || r == 6) && (c == 0 || c == 6) ) continue;

			//no problem if it's glass or floor
			if( tiles[ t + c + r * furlong ]->get_type() == TILE_GLASS || tiles[ t + c + r * furlong ]->get_type() == TILE_FLOOR ) continue;

			//if we're in the top left niche, lefthangs are fine
			if( r + c == 1 && tiles[ t + c + r * furlong ]->get_type() == TILE_LEFTHANG ) continue;

			//top right
			if( c == r + 5 && tiles[ t + c + r * furlong ]->get_type() == TILE_RIGHTHANG ) continue;

			//bottom left
			if( c == r - 5 && tiles[ t + c + r * furlong ]->get_type() == TILE_LEFTWEDGE ) continue;

			//bottom right
			if( r + c == 11 && tiles[ t + c + r * furlong ]->get_type() == TILE_RIGHTWEDGE ) continue;

			//if we're here, then there's a bad block
			return 1;
		}
	}

	//if we're here, all's well
	return 0;
}
int angel::get_x()
{
	if( !on ) return 0;

	return x;
}
int angel::get_y()
{
	if( !on ) return 0;

	return y;
}
bool angel::get_seraphim()
{
	return seraphim;
}
bool angel::get_on()
{
	return on;
}
void angel::kill( angel *angels[], particle *release )
{
	//shake the screen
	shake = 12;

	//turn it off
	on = 0;

	//and if you're a special angel, maybe restart the level?
	if( seraphim )
	{
		//heh, this comes before the check to stop them from checking themselves
		seraphim = 0;

		//whether this was the last one.
		bool last = 1;

		//if there are none left (we already know there was one to begin with, because here we are)
		for( int a = 0; a < TOTAL_ANGELS; a++ )
		{
			//if there's another seraphim, the player still has work to do. Dead angels are never seraphim.
			//do class members have access to one another's info?
			if( angels[ a ]->get_seraphim() )
			{				
				last = 0;
			}
		}

		//so, was it actually the last? If so, we just need to make a level-ending particle
		if( last )
		{
			Mix_HaltChannel( 1 );
			Mix_PlayChannel( 1, crotales, 0 );

			release->relocate( x, y, 5, 1 );
		}			
		else
		{
			//well, if you weren't, we need to play the sound here.
			Mix_HaltChannel( 2 );
			Mix_PlayChannel( 2, la, 0 );

			//and make a regular angel particle
			release->relocate( x, y, 5, 0 );
		}
	}

	//put it out of the way
	x = 0;
	y = 0;
}
void end()
{
	//delay
	SDL_Delay( 4000 );

	//play an extra sound?
}
bool set_tiles( Tile *tiles[], Avatar *myAvatar, angel *angels[], stone *stones[], bool *quit, bool firsttime )
{
	//special tiles
	/*
	int TILE_GARGOYLE = 7;
	int TILE_AVATAR = 8;
	int TILE_GLASS_ANGEL = 9;
	*/

	if( level == 2 )
	{
		KeyFadeFrame = 255;
	}

	//this is the weird variable that helps randomize the length of Doppler's pipe. The addition to the delay is .5 seconds times this.
	int dopplerweird = rand() % 6;

    //The tile offsets
    int x = 0, y = 0;

	//the cursors that will ensure that when an angel or gargoyle is created, previous ones won't be erased
	int stonecursor = 0;
	int angelcursor = 0;

	//the map we'll use
	std::ifstream map;

	//we introduce another kind of black box tile. It requires no lead rim.
	//What happens is that every glass or non-box tile makes the 36 nonglass tiles around it cream.

	if( level > LAST_LEVEL ) map.open( "other tester.map" ); //load the test level
	else map.open( levels[ level ] ); //just load the level
	

    //If the map couldn't be loaded
    if( map == NULL )
    {
        return false;
    }
	

    //Initialize the tiles
    for( int t = 0; t < TOTAL_TILES; t++ )
    {
        //Determines what kind of tile will be made
        int tileType = -1;

        //Read tile from map file
        map >> tileType;

        //If the was a problem in reading the map
        if( map.fail() == true )
        {
            //Stop loading map
            map.close();
            return false;
        }



        //If the number is a valid tile number
        if( ( tileType >= 0 ) && ( tileType < TILE_SPRITES ) )
        {
			
			//if it's an avatar block, make the avatar and set the block to something sensible
			if( tileType == 8 )
			{
				*myAvatar = Avatar( x, y, 0 );

				//make it glass
				tileType = 4;
			}

			//might want to spawn avatar on a ladder.
			if( tileType == 12 )
			{
				*myAvatar = Avatar( x, y - 7 * TILE_WIDTH, 1 );

				//make it floor
				tileType = 6;

				//and you know, obv it's a ladder, so let's deal with it here...
				if( !firsttime ) delete tiles[ t ];
				tiles[ t ] = new Tile( x, y, tileType, 0 );

				//this formality
				x += TILE_WIDTH;

				//so we continue
				continue;
			}

			//angels! You may have to add floor. If not, speedup opportunity: reduce TILE_SPRITES
			if( tileType == 9 )
			{
				//delete the angel previously there? Do you have to manually delete so much stuff?

				//the tile is at the center

				//new angel
				angels[ angelcursor ] = new angel( x - 7 * TILE_WIDTH, y - 7 * TILE_HEIGHT, 0 );

				//move the cursor
				angelcursor++;

				//if you've created more angels than you're allowed, you're a naughty boy!
				if( angelcursor > TOTAL_ANGELS ) return false;

				//make it glass
				tileType = 4;
			}
			

			//Seraphim. Special case of angels.
			if( tileType == 11 )
			{
				//delete the angel previously there? Do you have to manually delete so much stuff?

				//the tile is at the center

				//new angel
				angels[ angelcursor ] = new angel( x - 7 * TILE_WIDTH, y - 7 * TILE_HEIGHT, 1 );

				//move the cursor
				angelcursor++;

				//if you've created more angels than you're allowed, you're a naughty boy!
				if( angelcursor > TOTAL_ANGELS ) return false;

				//make it glass
				tileType = 4;
			}

			//Might want to spawn angel on a ladder
			if( tileType == 13 )
			{
				//delete the angel previously there? Do you have to manually delete so much stuff?

				//the tile is at the center

				//new angel
				angels[ angelcursor ] = new angel( x - 7 * TILE_WIDTH, y - 7 * TILE_HEIGHT, 1 );

				//move the cursor
				angelcursor++;

				//if you've created more angels than you're allowed, you're a naughty boy!
				if( angelcursor > TOTAL_ANGELS ) return false;

				//make it glass
				tileType = 6;
			}

			//gargoyles
			if( tileType == 7 )
			{
				//delete the stone that was previously there?

				//make a stone.
				stones[ stonecursor ] = new stone( x, y );

				//move on to the next stone
				stonecursor++;

				//if you've created more stones than you're allowed, you're a naughty boy!
				if( stonecursor > TOTAL_STONES ) return false;

				//make the tile glass. Hopefully you won't have to make it floor ever.				
				tileType = 4;
			}

			//clear it if need be. WARNING: If the player restarts on the first level, 
			if( !firsttime ) delete tiles[ t ];

			//if it's a floor tile, and the tile above was also floor
			if( tileType == TILE_FLOOR && tiles[ t - furlong ]->get_type() != TILE_FLOOR)
			{
				//we make it a ladder
				tiles[ t ] = new Tile( x, y, tileType, 1 );
			}
			else
			if( level == LAST_LEVEL - 1 ) //if it's doppler we need to randomize the length of the pipe
			{
				//if you're on either of the correct lines
				if( y == 24 * TILE_HEIGHT )
				{
					if( x == 788 + 8 * TILE_WIDTH * dopplerweird ) tileType = 3;
					if( x == 788 + 8 * TILE_WIDTH * dopplerweird + TILE_WIDTH ) tileType = 5;
				}
				else
				if( y == 65 * TILE_HEIGHT )
				{
					if( x == 624 + 8 * TILE_WIDTH * dopplerweird ) tileType = 3;
				}

				tiles[ t ] = new Tile( x, y, tileType, 0 );
			}
			else tiles[ t ] = new Tile( x, y, tileType, 0 );
			
        }
        //If we don't recognize the tile type
        else
        {
            //Stop loading map
            map.close();
            return false;
        }

        //Move to next tile spot
        x += TILE_WIDTH;

        //If we've gone too far
        if( x >= LEVEL_WIDTH )
        {
            //Move back
            x = 0;

            //Move to the next row
            y += TILE_HEIGHT;
        }
    }

	//initialize the rest of the stones and angels to make sure the previous level's don't leak into this level
	for( int i = angelcursor; i < TOTAL_ANGELS; i++ )
	{
		angels[ i ] = new angel( 0, 0, 0 );
	}
	for( int i = stonecursor; i < TOTAL_STONES; i++ )
	{
		stones[ i ] = new stone( 0, 0 );
	}


	//go over the tiles again and make cream what needs to be cream
	for( int t = 0; t < TOTAL_TILES; t++ )
    {

		//literally any kind of tile except for solid blocks calls for a cream explosion
		if( tiles[ t ]->get_type() != 5 )
		{
			for( int i = 0; i < 7; i++ )
			{
				for( int j = 0; j < 7; j++ )
				{
					//never mind the outer-edge ones
					
					if(
						     ( i == 0 || i == 6
						  || j == 0 || j == 6 )
						  && i != 2 && i != 3 && i != 4
						  && j != 2 && j != 3 && j != 4 )
						  continue;
						  
					//if you're within acceptable bounds, creamify!
					if( 0 <= ( t - 3 - 3 * 512 ) + ( i + j * 512 ) && ( t - 3 - 3 * 512 ) + ( i + j * 512 ) < TOTAL_TILES )
						tiles[ ( t - 3 - 3 * 512 ) + ( i + j * 512 ) ]->make_cream();
				}
			}
		}
	}
	//to remove jutting-out ones, you could go through it all again and look at the eight around each noncream, and if there's less than 2, decream.





    //Close the file
    map.close();
	

    //If the map was loaded fine
    return true;
}
//takes in ray, pictures, and does the right thing to the pixel
void write( Uint32 rayR, Uint32 rayG, Uint32 rayB, Uint32 j, Uint32 *wall, Uint32 *glass, SDL_PixelFormat *fmt, Uint32 pixel )
{
	Uint8 rgbs[3];

	//get what the 4 pixels looks like without rays
	SDL_GetRGB( wall[ pixel ], fmt,	&rgbs[0], &rgbs[1], &rgbs[2] );

	//alternatively
	//rgbs[0][0] = glassRGBs[ pixel ][ 0 ]

	//hacky, get rid of asap
	//if( i == SCREEN_WIDTH / 2 - SCREEN_HEIGHT / 2 ) rays[a][b] *= 1.003;

	//big problems with the very middle

	//this takes the value between the pixel (rgbs) and the average of the rays (rays / j)
	rgbs[0] = ( rayR + rgbs[0] * (320-j) ) / 320; //treats rays as though they take nothing away
	rgbs[1] = ( rayG + rgbs[1] * (320-j) ) / 320;
	rgbs[2] = ( rayB + rgbs[2] * (320-j) ) / 320;
	//rgbs[2] = ( rayB + rgbs[2] * (320-j) ) / 320;
	//rgbs[a] = ( rgbs[a] + rayR / (j+1) ) / 2; //regular average
	//rgbs[a] = rgbs[a] * 2 / 3 + rayR / (j+1) / 3; //average adjusted a little. Combine this with foregrounded wood?

	//and put it back into the output
	wall[ pixel ] = SDL_MapRGB( fmt, rgbs[0], rgbs[1], rgbs[2] );
}
//get_pixel: Acquires a 32-bit pixel from a surface at given coordinates
void graphics( SDL_Surface *input, SDL_Surface *output )
{
	/*
	//the layers will be: brick, glass(which includes gameplay), shafts. Layered on top of each other in that order.

	//you could put some flickering in here. Could take a basic random number and if it's below a certain value, skip reading from a pixel.

	//mkay, something guaranteed fast and ok-looking would just be the flat Symphony of the night style.
	//while walking through, if you get a series of same-coloured pixels, just treat them as one.
	//so this would require another little array: priors[4][3]
	//a better solution for 

	//would making input 256 colour improve things?

	//also another way to speed up is to mirror the whole thing yet again along the diagonal.

	//get the array of pixels from the glass, convert to 32 bit. now the pixel ( x , y ) is glass[ ( y * surface->w ) + x ];
    Uint32 *glass = (Uint32 *)input->pixels;

	//these are the pixels we will write to. Perhaps you should turn both of these into RGB right here?
	Uint32 *wall = (Uint32 *)output->pixels;

	//get the format of the surface
	SDL_PixelFormat *fmt = input->format;

	//here is where we store the colour of wood
	Uint8 d;
	Uint8 e;
	Uint8 f;

	//get the colorkey; we use this to stop the blending of wood-colored light
	SDL_GetRGB( fmt->colorkey, fmt,	&d, &e, &f );

	//the accumulated colours of pixels. TL, TR, BL, BR. R, G, B, amount of black. You might be able to get away with Uint16
	Uint32 rays[4][4];

	//the variables we use to get info
	Uint8 rgbs[4][3];

	//the address of a pixel to be READ, it's an entry in scheme[][] and we use it to find a place in glass[]. It looks like it would be better if we took an x and y from scheme[][][]. Then Uint8.
	Uint32 pixel;

	//just use these to index
	Uint8 a, b;

	//put all the RGBs from the source picture in the array. This takes a while but is prob. necesary.
	
	for( int i = 0; i < SCREEN_WIDTH * SCREEN_HEIGHT; i++ )
	{
		SDL_GetRGB( glass[ i ], fmt, &glassRGBs[ i ][ 0 ], &glassRGBs[ i ][ 1 ], &glassRGBs[ i ][ 2 ] );
	}
	

	//there's probably a good sequence you can have that involves taking advantage of the fact that adding and dividing makes results from a long time ago less and less significant

	//the right thing to do for the diagonal may be to log the contributions of the lines above and below it and then average them at the end.
	//can we get something going with forks? If you want this to go on mobiles maybe.
	//Uint32 cornerline[320];
	//Uint32 diagline[120];
	
	//go through each of the lines.
	for( int i = 0; i < 320; i++ )
	{
		//if it's the perfect diag, we've other ways of dealing with it
		if( i == SCREEN_WIDTH / 2 - SCREEN_HEIGHT / 2 ) continue;

		//and sometimes we just don't bother coz something's blocking the light?
		//if( rand() < 900 ) continue;

		//beginning a new bunch of rays, need to clear
		for( a = 0; a < 4; a++ )
		{
			for( b = 0; b < 3; b++ )
			{
				rays[a][b] = 0;
				rgbs[a][b] = 0;
			}
			rays[a][3] = 0;
		}

		//we get a row of pixel addresses to look at for the pixel at the end of this line, 320 at most
		for( int j = 0; j < 320; j++ )
		{
			//see what pixel we are to read
			pixel = scheme[ i ][ j ];

			//you can VERY easily multithread this

			//should we write to this pixel? Checkpoints will tell us. Also you don't want to colour things if we're talking about the very first pixel.
			if( j && checkpoints[ i ][ j ] )
			{
				//write to it!
				write( rays[0][0], rays[0][1], rays[0][2], rays[0][3], wall, glass, fmt, pixel );
				write( rays[1][0], rays[1][1], rays[1][2], rays[1][3], wall, glass, fmt, pixel + SCREEN_WIDTH - 2 * ( pixel % SCREEN_WIDTH ) -1 );
				write( rays[2][0], rays[2][1], rays[2][2], rays[2][3], wall, glass, fmt, ( SCREEN_HEIGHT - ( pixel / SCREEN_WIDTH ) -1 ) * SCREEN_WIDTH + ( pixel % SCREEN_WIDTH ) );
				write( rays[3][0], rays[3][1], rays[3][2], rays[3][3], wall, glass, fmt, ( SCREEN_HEIGHT - ( pixel / SCREEN_WIDTH ) ) * SCREEN_WIDTH - ( pixel % SCREEN_WIDTH ) -1 );

				if( pixel % SCREEN_WIDTH - SCREEN_WIDTH / 2 + SCREEN_HEIGHT / 2 + 1 == pixel / SCREEN_WIDTH  )
				{
					write( rays[0][0], rays[0][1], rays[0][2], rays[0][3], wall, glass, fmt, pixel + 1 );
					write( rays[1][0], rays[1][1], rays[1][2], rays[1][3], wall, glass, fmt, pixel + SCREEN_WIDTH - 2 * ( pixel % SCREEN_WIDTH ) -2 );
					write( rays[2][0], rays[2][1], rays[2][2], rays[2][3], wall, glass, fmt, ( SCREEN_HEIGHT - ( pixel / SCREEN_WIDTH ) -1 ) * SCREEN_WIDTH + ( pixel % SCREEN_WIDTH ) + 1  );
					write( rays[3][0], rays[3][1], rays[3][2], rays[3][3], wall, glass, fmt, ( SCREEN_HEIGHT - ( pixel / SCREEN_WIDTH ) ) * SCREEN_WIDTH - ( pixel % SCREEN_WIDTH ) -2 );
				}
			}

			//have we reached the end? You'll never want to read pixel 0, so if you read that you're done with this line
			if( pixel == 0 ) break;

			//get the R, G, B from the pixel with that address. Speedup opportunity: GetRGBs in a big batch to begin with
			SDL_GetRGB( glass[ pixel																						], fmt,	&rgbs[0][0], &rgbs[0][1], &rgbs[0][2] );
			SDL_GetRGB( glass[ pixel + SCREEN_WIDTH - 2 * ( pixel % SCREEN_WIDTH )									  - 1 	], fmt,	&rgbs[1][0], &rgbs[1][1], &rgbs[1][2] );
			SDL_GetRGB( glass[ ( SCREEN_HEIGHT - ( pixel / SCREEN_WIDTH ) - 1 ) * SCREEN_WIDTH + ( pixel % SCREEN_WIDTH )	], fmt,	&rgbs[2][0], &rgbs[2][1], &rgbs[2][2] );
			SDL_GetRGB( glass[ ( SCREEN_HEIGHT - ( pixel / SCREEN_WIDTH ) ) * SCREEN_WIDTH - ( pixel % SCREEN_WIDTH ) - 1	], fmt,	&rgbs[3][0], &rgbs[3][1], &rgbs[3][2] );

			//add them to the load of rays
			for( a = 0; a < 4; a++ )
			{
				//only bother if it's not black
				if( !( rgbs[a][0] == 0 && rgbs[a][1] == 0 && rgbs[a][2] == 0 ) && !( rgbs[a][0] == 0 && rgbs[a][1] == 255 && rgbs[a][2] == 255 )  )
				{
					for( b = 0; b < 3; b++ )
					{						
						rays[a][b] += rgbs[a][b];

						//and if they're black, it shouldn't have an impact. How to implement?
						//have a fourth row in rgbs and rays.
					}

					//and we increase the number of readings in there.
					rays[a][3]++;
					if( rays[a][3] > j ) rays[a][3] = j;
				}
			}
		}
	}
	*/
}

//generate scheme, which tells a pixel on the edge which pixels to read, starting in the middle
//and checkpoints, which says whether a pixel to be read should also be written to.
void generate()
{
	/*
	//set it so that none of the lines affect anything to begin with.
	for( int i = 0; i < 320; i++ )
	{
		for( int j = 0; j < 320; j++ )
		{
			checkpoints[ i ][ j ] = 0;
		}
	}

	//we walk up the squares in the right order by looking at the line's intersection with diagonal lines.
	//the equation of the crossing line is c + k - x - y = 1, 2, 3... = A
	//and the equation of a given ray can be made to be k - y = m( x - c) therefore k - y - mx + mc = 0
	//therefore c - x - mc + mx = A = c(1-m) - x(1-m) = (c-x)(1-m)
	//therefore x = c - A/(1-m)

	//n = 1/m
	//for y: c-x = n(y-k) therefore c - x - ny + nk = 0	
	//therefore k - y + yn - kn = A = k(1-n) - y(1-n) = (k-y)(1-n)
	//therefore y = k - A/(1-n)
	

	//change the above a bit and we get ( c-A/(1+m), k-A/(1+m) ) from m = (k-y)/(c-x)

	//Putting in an A and an m gives the co ord of one point for every square we pass through. Lop off the decimal, get the associated square.
	//Since the address of the pixel is y*Screen_width+x, we get index =  z - A/(1-m) * (SW+1) where z = k * SW + c.
	//we use all the As from 1 up until the point when y < 0 or x < 0.


	//center of the screen. Would it be easier if this was the origin?
	//Change c to get 3DS pics. Probably nicest place is with the diagonals hitting the corners i.e. c = k and c = SCREEN_WIDTH - k.
	int c = SCREEN_WIDTH / 2;
	int k = SCREEN_HEIGHT / 2;

	//gradient of lines
	float m, sampleM;

	//to get an m without expensive division, you could just add 2/(2*(x-c)+1) i.e. a constant for all x. You could actually have a list of these. Or at least have some worked out from others
	//How to get rid of taking inverse m as well?
	float xcross, ycross;

	//the main unpleasant part is the fact that black seems to shine. Hard to see how it can be to do with anything but samples...
	//you need to make it clearer what light is coming from where. Like a pane should have an identifiable shaft.
	//it looks terrible when a shaft is limited, and it doesn't look great

	int y = 0;
	int x = 0;

	int sampleX, sampleY;

	int A;

	//all lines along the top have 119 horiz-line intersections as one another. All the ones along the side have 199 vert-line intersections.

	//want more lines? draw them to the bottom right of the pixels you're currently drawing them to the middle of. that'll be even.

	//the top left is a special case, as it has to take in pixels from below and above the diagonal distinction.
	for( A = 1; A < 320; A++ )
	{
		//just do same as below
		m = 2*k - 1;
		m /= -2*c + 1;

		sampleX = c - A/(1-m);
		sampleY = k - A/(1-1/m);

		if( sampleX < 0 || sampleY < 0 ) break;

		scheme[ 0 ][ A - 1 ] = sampleY * SCREEN_WIDTH + sampleX;

		//and do we fill in the pixel as well? depends on whether it is closer to the line associated with x=1 and y = 1.
		sampleM  = 2 * (k - sampleY) - 1;
		sampleM /= 2 * (sampleX - c) + 1;

		xcross = (2 * k - 1) / sampleM;
		ycross = sampleM * (2 * (0-c) + 1);

		//is m a good approximation? Have to look at both sides
		if(		( -1 < xcross - (2 * k - 1) / m && xcross - (2 * k - 1) / m < 1 )
			||	( -1 < ycross - m * (2 * (0-c) + 1) && ycross - m * (2 * (0-c) + 1) < 1 )
			)
					checkpoints[ 0 ][ A - 1 ] = 1;
	}

	for( x = 1; x < c; x++ )
	{
		//we're talking about a pixel with y = 0. We get the gradient of the line going to its center.
		//this gradient is k - y / c - x, so if you want new
		m  = 2 * (k-0) - 1;
		m /= 2 * (x-c) + 1;

		//we go through all the pixels, starting at the center, that line crosses
		for( A = 1; A < 320; A++ )
		{
			//get the co ords of the pixel. m is never 1.
			sampleX = c - A/(1-m);
			sampleY = k - A/(1-1/m);

			//if we're off the edge of the picture, we can stop!
			if( sampleX < 0 || sampleY < 0 ) break;

			//put the address of the pixel we've gotten into the array
			scheme[ x ][ A - 1 ] = sampleY * SCREEN_WIDTH + sampleX;





			//and is it the case that we fill this pixel in as well? Depends on what its m is closest to.
			sampleM  = 2 * (k - sampleY) - 1;
			sampleM /= 2 * (sampleX - c) + 1;

			//so where does the sample's line cross k - y = 2 * k - 1, where we know all our proper lines have int crossings?
			xcross = (2 * k - 1) / sampleM;

			//take the distance between that cross and where our m crosses. If it's close to our m, associate it with m. Let them squabble over the corner ones
			if( -1 < xcross - (2 * k - 1) / m && xcross - (2 * k - 1) / m < 1 )
				checkpoints[ x ][ A - 1 ] = 1;
		}

		//now we're done with the line, we can round it off
		scheme[ x ][ A - 1 ] = 0;
	}

	//we've already done 0,0.
	for( y = 1; y < k; y++ )
	{
		//special case for top corner stuff
		
		if( y )
		{
		}
		else
		

		//we're talking about a pixel with x = 0. We get the gradient of the line going to its center.
		//this gradient is k - y / c - x, so if you want new
		m = 2 * (k-y) - 1;
		m /= 2 * (0-c) + 1;

		//we go through all the pixels, starting at the center, that line crosses
		for( A = 1; A < 320; A++ )
		{
			sampleX = c - A/(1-m);
			sampleY = k - A/(1-1/m);

			//if we're off the edge of the picture, we can stop!
			if( sampleX < 0 || sampleY < 0 ) break;

			//put the address of the pixel we've gotten into the array
			scheme[ y + c - 1 ][ A - 1 ] = sampleY * SCREEN_WIDTH + sampleX;

			//the problem is with pixels: 1,1  6,4  11,7,  16,10  21,13  26,16... 140,84
			//so 


			//and is it the case that we fill this pixel in as well? Depends on whether its line crosses horizontal lines closest to m.
			sampleM =  2 * (k - sampleY) - 1;
			sampleM /= 2 * (sampleX - c) + 1;

			//so where does the sample's line cross x - c = 2 * -c + 1, where we know all our proper lines have int crossings?
			ycross = sampleM * (2 * (0-c) + 1);

			//take the distance between that cross and where our m crosses. If it's close to our m, associate it with m. Let them squabble over the corner ones
			if( -1 < ycross - m * (2 * (0-c) + 1) && ycross - m * (2 * (0-c) + 1) < 1 )
				checkpoints[ y + c - 1 ][ A - 1 ] = 1;

			//there are some pixels just inside this one which aren't being accounted for. They should be associated with x == 0.
			//we could take a ginormous list of pixels and cross them off as they are accounted for, then just associate the remainders with x == 0.
		}

		//now we're done with the line, we can round it off
		scheme[ y + c - 1 ][ A - 1 ] = 0;
	}
	*/
}
//tool for checking if both sides of graphics work ok
void horizflip( SDL_Surface* surface )
{
	Uint32 *pixels = (Uint32 *)surface->pixels;

	Uint32 left = 0;
	Uint32 right = 0;

    for (int y = 0; y < SCREEN_HEIGHT; y++ )
    {
        for (int x = 0; x < SCREEN_WIDTH / 2; x++ )
        {
			left = pixels[ ( y * SCREEN_WIDTH ) + x ];
			right = pixels[ ( y * SCREEN_WIDTH ) - x + SCREEN_WIDTH ];
			pixels[ ( y * SCREEN_WIDTH ) + x ] = right;
			pixels[ ( y * SCREEN_WIDTH ) - x + SCREEN_WIDTH ] = left;
        }
    }
}
Timer::Timer()
{
    //Initialize the variables
    startTicks = 0;
    pausedTicks = 0;
    paused = false;
    started = false;
}

void Timer::start()
{
    //Start the timer
    started = true;

    //Unpause the timer
    paused = false;

    //Get the current clock time
    startTicks = SDL_GetTicks();
}

void Timer::stop()
{
    //Stop the timer
    started = false;

    //Unpause the timer
    paused = false;
}

void Timer::pause()
{
    //If the timer is running and isn't already paused
    if( ( started == true ) && ( paused == false ) )
    {
        //Pause the timer
        paused = true;

        //Calculate the paused ticks
        pausedTicks = SDL_GetTicks() - startTicks;
    }
}

void Timer::unpause()
{
    //If the timer is paused
    if( paused == true )
    {
        //Unpause the timer
        paused = false;

        //Reset the starting ticks
        startTicks = SDL_GetTicks() - pausedTicks;

        //Reset the paused ticks
        pausedTicks = 0;
    }
}

int Timer::get_ticks()
{
    //If the timer is running
    if( started == true )
    {
        //If the timer is paused
        if( paused == true )
        {
            //Return the number of ticks when the timer was paused
            return pausedTicks;
        }
        else
        {
            //Return the current time minus the start time
            return SDL_GetTicks() - startTicks;
        }
    }

    //If the timer isn't running
    return 0;
}

bool Timer::is_started()
{
    return started;
}

bool Timer::is_paused()
{
    return paused;
}

void Avatar::loopify()
{
	//move it up
	y -= 92;
}
void stone::loopify()
{
	//move it up
	y -= 92;
}
void Bead::loopify()
{
	//move it up
	y -= 92;

	//just in case
	if( y <= 0 ) { y = 4; x = 480; }
}

void particle::loopify()
{
	//move it up
	y -= 92;
}

void level_transition( Timer *fps )
{
	//don't really wanna touch camera, use this as the viewport.
	SDL_Rect view = { 4, 0, 400, 240 };

	//no here's what you do: compile pictures of every level on one image and have the camera move around it. That gives you something to do with the empty space off to the sides

	//the speed we're going in the current frame
	int speed = 1;

	//how many frames there's been
	int frames = 0;

	//play a nice sound
	Mix_PlayChannel( 6, transition, 0 );

	//loop
	while( view.x < 800 )
	{
		//show on the screen
		apply_surface( 0, 0, transitionstrip, temp, &view );

		//show crosses
		for( int i = level - 1; i < 45; i++ )
		{
			apply_surface( 404 - view.x +  + CrossesClips[ i ].x, CrossesClips[ i ].y, Crosses, temp, &CrossesClips[ i ] );
		}

		//blow it up
		Increase( bigscreen, temp, 2 );

		//flip it
		SDL_Flip( bigscreen );

		//Cap the frame rate
        if( fps->get_ticks() < 1000 / FRAMES_PER_SECOND )
        {
            SDL_Delay( ( 1000 / FRAMES_PER_SECOND ) - fps->get_ticks() );
        }

		//change the position
		view.x += speed;

		//update
		frames++;

		//800 = a * t^2

		//increase speed until you're going a good pelt. Start toning back once you've reached... a place to be tuned.
		if( frames % 4 == 0 && speed < 6 ) speed += 1;
		else
		if( frames % 3 == 0 && view.x > 412 && speed > 1 ) speed -= 1;		
	}
}

void manualappending( int frames, char *leftmostdigit, char *middlemostdigit, char *rightmostdigit )
{
	//insert whichever number it is into the units
	if( frames % 10 == 0 ) *rightmostdigit = '0';
	if( frames % 10 == 1 ) *rightmostdigit = '1';
	if( frames % 10 == 2 ) *rightmostdigit = '2';
	if( frames % 10 == 3 ) *rightmostdigit = '3';
	if( frames % 10 == 4 ) *rightmostdigit = '4';
	if( frames % 10 == 5 ) *rightmostdigit = '5';
	if( frames % 10 == 6 ) *rightmostdigit = '6';
	if( frames % 10 == 7 ) *rightmostdigit = '7';
	if( frames % 10 == 8 ) *rightmostdigit = '8';
	if( frames % 10 == 9 ) *rightmostdigit = '9';

	//insert what you need into the middle digit
	if( frames % 100 - frames % 10 == 0 ) *middlemostdigit = '0';
	if( frames % 100 - frames % 10 == 10 ) *middlemostdigit = '1';
	if( frames % 100 - frames % 10 == 20 ) *middlemostdigit = '2';
	if( frames % 100 - frames % 10 == 30 ) *middlemostdigit = '3';
	if( frames % 100 - frames % 10 == 40 ) *middlemostdigit = '4';
	if( frames % 100 - frames % 10 == 50 ) *middlemostdigit = '5';
	if( frames % 100 - frames % 10 == 60 ) *middlemostdigit = '6';
	if( frames % 100 - frames % 10 == 70 ) *middlemostdigit = '7';
	if( frames % 100 - frames % 10 == 80 ) *middlemostdigit = '8';
	if( frames % 100 - frames % 10 == 90 ) *middlemostdigit = '9';

	//aaand the harry hundreds
	if( frames - frames % 100 - frames % 10 == 0 ) *leftmostdigit = '0';
	if( frames - frames % 100 - frames % 10 == 100 ) *leftmostdigit = '1';
	if( frames - frames % 100 - frames % 10 == 200 ) *leftmostdigit = '2';
	if( frames - frames % 100 - frames % 10 == 300 ) *leftmostdigit = '3';
	if( frames - frames % 100 - frames % 10 == 400 ) *leftmostdigit = '4';
	if( frames - frames % 100 - frames % 10 == 500 ) *leftmostdigit = '5';
	if( frames - frames % 100 - frames % 10 == 600 ) *leftmostdigit = '6';
	if( frames - frames % 100 - frames % 10 == 700 ) *leftmostdigit = '7';
	if( frames - frames % 100 - frames % 10 == 800 ) *leftmostdigit = '8';
	if( frames - frames % 100 - frames % 10 == 900 ) *leftmostdigit = '9';
} 
void play_Torusvideo()
{
	//victory sink-in
	SDL_Delay(300);

	Mix_Pause( 0 );

	//how many frames there's been
	int frames = 32;

	//the name of the file with the frame we want, assigned the first part of every file's name
	char filename[] = "Torusanimation/25.png";

	char dummy = 0;

	//sound
	Mix_PlayChannel( 1, harmonic, 0 );

	Timer temptimer;

	//loop
	while( frames >= 0 )
	{
		temptimer.start();

		//we implant the number in the string, although we have to worry if it's a single digit
		manualappending( frames, &dummy, &filename[15], &filename[16] );

		//create a surface
		SDL_Surface *pic;
		

		if( frames <= 25 ) pic = load_image( filename );
		else
		if( Torusrightward )
		{
			if( frames == 32 ) pic = load_image( "Torusanimation/rightward01.png" );
			if( frames == 31 ) pic = load_image( "Torusanimation/rightward02.png" );
			if( frames == 30 ) pic = load_image( "Torusanimation/rightward03.png" );
			if( frames == 29 ) pic = load_image( "Torusanimation/rightward04.png" );
			if( frames == 28 ) pic = load_image( "Torusanimation/rightward05.png" );
			if( frames == 27 ) pic = load_image( "Torusanimation/rightward06.png" );
			if( frames == 26 ) pic = load_image( "Torusanimation/rightward07.png" );
		}
		else
		{
			if( frames == 32 ) pic = load_image( "Torusanimation/leftward01.png" );
			if( frames == 31 ) pic = load_image( "Torusanimation/leftward02.png" );
			if( frames == 30 ) pic = load_image( "Torusanimation/leftward03.png" );
			if( frames == 29 ) pic = load_image( "Torusanimation/leftward04.png" );
			if( frames == 28 ) pic = load_image( "Torusanimation/leftward05.png" );
			if( frames == 27 ) pic = load_image( "Torusanimation/leftward06.png" );
			if( frames == 26 ) pic = load_image( "Torusanimation/leftward07.png" );
		}

		SDL_PollEvent( &event );
		//if it's not there then never mind the video; same if the player wants to quit.
		if( pic == NULL || event.type == SDL_QUIT ) break;

		//show on the screen
		apply_surface( 0, 0, pic, temp );

		//free the surface
		SDL_FreeSurface( pic );

		//blow it up
		Increase( bigscreen, temp, 2 );

		//flip it
		SDL_Flip( bigscreen );

		//delay
		SDL_Delay( 90 );

		//delay at the end
		if( frames == 0 ) { Mix_FadeOutChannel( 1, 450 ); SDL_Delay( 1400 ); }

		//update
		frames--;

		if( temptimer.get_ticks() < 1000 / FRAMES_PER_SECOND )
        {
            SDL_Delay( ( 1000 / FRAMES_PER_SECOND ) - temptimer.get_ticks() );
        }

		//maybe you should make it so the window can be closed without crashing?
	}

	//fade out the music
	Mix_FadeOutChannel( 1, 700 );

	Mix_Resume( 0 );
}
void play_garbead1video()
{
	Mix_Pause( 0 );

	//how many frames there's been
	int frames = 1;

	//the name of the file with the frame we want, assigned the first part of every file's name
	char filename[] = "gargbead animation/01.png";

	char dummy = 0;

	//sound
	Mix_PlayChannel( 1, harmonic, 0 );

	Timer temptimer;

	//loop
	while( frames <= 17 )
	{
		temptimer.start();

		//we implant the number in the string, although we have to worry if it's a single digit
		manualappending( frames, &dummy, &filename[19], &filename[20] );

		//create a surface
		SDL_PollEvent( &event );
		SDL_Surface *pic = load_image( filename );

		//if it's not there then never mind the video; same if the player wants to quit.

		if( pic == NULL || event.type == SDL_QUIT ) break;

		//show on the screen
		apply_surface( 0, 0, pic, temp );

		//free the surface
		SDL_FreeSurface( pic );

		//blow it up
		Increase( bigscreen, temp, 2 );

		//flip it
		SDL_Flip( bigscreen );

		//delay
		SDL_Delay( 90 + (16-frames) );

		//update
		frames++;

		if( temptimer.get_ticks() < 1000 / FRAMES_PER_SECOND )
        {
            SDL_Delay( ( 1000 / FRAMES_PER_SECOND ) - temptimer.get_ticks() );
        }

		//don't want to be abrupt. Also fade out here
		if( frames == 18 ) { Mix_FadeOutChannel( 1, 450 ); SDL_Delay( 1400 ); }

		//maybe you should make it so the window can be closed without crashing?
	}

	Mix_Resume( 0 );
}
void play_garbead2video()
{
	Mix_Pause( 0 );

	//how many frames there's been
	int frames = 0;

	//the name of the file with the frame we want, assigned the first part of every file's name
	char filename[] = "gargbead2 animation/00.png";

	char dummy = 0;

	//sound
	Mix_PlayChannel( 1, harmonic, 0 );

	Timer temptimer;

	//loop
	while( frames <= 16 )
	{
		temptimer.start();

		//we implant the number in the string, although we have to worry if it's a single digit
		manualappending( frames, &dummy, &filename[20], &filename[21] );

		//create a surface
		SDL_PollEvent( &event );
		SDL_Surface *pic = load_image( filename );

		//if it's not there then never mind the video; same if the player wants to quit.

		if( pic == NULL || event.type == SDL_QUIT ) break;

		//show on the screen
		apply_surface( 0, 0, pic, temp );

		//free the surface
		SDL_FreeSurface( pic );

		//blow it up
		Increase( bigscreen, temp, 2 );

		//flip it
		SDL_Flip( bigscreen );

		//delay
		SDL_Delay( 90 + (16-frames) );

		//update
		frames++;

		if( temptimer.get_ticks() < 1000 / FRAMES_PER_SECOND )
        {
            SDL_Delay( ( 1000 / FRAMES_PER_SECOND ) - temptimer.get_ticks() );
        }

		//don't want to be abrupt
		if( frames == 17 ) { Mix_FadeOutChannel( 1, 450 ); SDL_Delay( 1400 ); }
	}

	Mix_Resume( 0 );
}
void play_video()
{
	Mix_Pause( 0 );

	//how many frames there's been
	int frames = 1;

	//the name of the file with the frame we want, assigned the first part of every file's name
	char firstfilename[] = "ThereWereNoTutorials/F01.jpg";

	//dummy variable that we use to pretend there are three digits involved in our filename
	char dummy = 0;

	//We don't want it happening STRAIGHT away
	SDL_Delay( 280 );

	Timer temptimer;

	//loop
	while( frames <= 81 )
	{
		temptimer.start();

		//may want to skip some

		manualappending( frames, &dummy, &firstfilename[22], &firstfilename[23] );

		//create a surface
		SDL_PollEvent( &event );
		SDL_Surface *pic = load_image( firstfilename );

		//if it's not there then never mind the video; same if the player wants to quit.

		if( pic == NULL || event.type == SDL_QUIT ) break;

		//show on the screen
		apply_surface( 0, 0, pic, temp );

		//free the surface
		SDL_FreeSurface( pic );

		//blow it up
		Increase( bigscreen, temp, 2 );

		//flip it
		SDL_Flip( bigscreen );

		//delay
		SDL_Delay( 20 );

		//and we want some acceleration, so an extra delay at the beginning and end
		if( frames < 30 ) SDL_Delay( 60 - 2 * frames );
		if( frames > 51 ) SDL_Delay( 2 * (frames - 51) );

		//update
		frames++;

		if( temptimer.get_ticks() < 1000 / FRAMES_PER_SECOND )
        {
            SDL_Delay( ( 1000 / FRAMES_PER_SECOND ) - temptimer.get_ticks() );
        }

		//maybe you should make it so the window can be closed without crashing?
	}


	//reset
	frames = 1;

	//the name of the file with the frame we want, assigned the first part of every file's name
	char filename[ 37 ] = "ThereWereNoTutorials/hamish2_001.jpg";

	//loop
	while( frames <= 800 )
	{
		temptimer.start();

		manualappending( frames, &filename[29], &filename[30], &filename[31] );

		//create a surface
		SDL_PollEvent( &event );
		SDL_Surface *pic = load_image( filename );

		//if it's not there then never mind the video; same if the player wants to quit.

		if( pic == NULL || event.type == SDL_QUIT ) break;

		//show on the screen
		apply_surface( 0, 0, pic, temp );

		//free the surface
		SDL_FreeSurface( pic );

		//blow it up
		Increase( bigscreen, temp, 2 );

		//flip it
		SDL_Flip( bigscreen );

		//delay
		SDL_Delay( 12 );

		//extra delay because the last 8 squares are a tad fast
		if( frames >= 256 && frames <= 270 ) SDL_Delay( 270 - frames );
		if( frames >= 289 && frames <= 306 ) SDL_Delay( 306 - frames );

		//update
		frames++;

		if( temptimer.get_ticks() < 1000 / FRAMES_PER_SECOND )
        {
            SDL_Delay( ( 1000 / FRAMES_PER_SECOND ) - temptimer.get_ticks() );
        }

		//maybe you should make it so the window can be closed without crashing?
	}

	//and you want it to sink in
	SDL_Delay( 500 );

	Mix_Resume( 0 );
}

void play_ending()
{
	//no more music
	Mix_Pause( 0 );

	//we're just showing three pics
	int count = 0;

	while( count < 4 )
	{
		//create a surface
		SDL_PollEvent( &event );
		SDL_Surface *pic;

		if( count == 0 ) pic = load_image( "Images/hyperbolic.png" );
		if( count == 1 ) pic = load_image( "Images/Escher.png" );
		if( count == 2 ) pic = load_image( "Images/chartres.png" );
		if( count == 3 ) pic = load_image( "Images/Blake.png" );

		//if it's not there then never mind the video; same if the player wants to quit.
		if( pic == NULL || event.type == SDL_QUIT ) break;

		//show on the screen
		apply_surface( 0, 0, pic, temp );

		//free the surface
		SDL_FreeSurface( pic );

		//blow it up
		Increase( bigscreen, temp, 2 );

		//flip it
		SDL_Flip( bigscreen );

		//delay
		SDL_Delay( 4000 );

		count++;
	}
}

void play_opening()
{
	//how many frames there's been
	int frames = 0;

	//the name of the file with the frame we want, assigned the first part of every file's name
	char filename[] = "nu nu nu opening/00.png";

	//dummy variable that we use to pretend there are three digits involved in our filename
	char dummy = 0;

	//sound
	Mix_Chunk *introsound = Mix_LoadWAV( "Sounds/intronoise.wav" );
	Mix_PlayChannel( 1, introsound, 0 );

	//yeah you really need to regulate the frame rate.

	Timer temptimer;

	//loop
	while( frames <= 21 )
	{
		temptimer.start();

		//skip the last zoom part.
		if( frames == 21 ) frames = 32;

		manualappending( frames, &dummy, &filename[17], &filename[18] );

		//create a surface
		SDL_Surface *pic = load_image( filename );

		//does the player want to quit?
		SDL_PollEvent( &event );

		//if it's not there then never mind the video; same if the player wants to quit.
		if( pic == NULL || event.type == SDL_QUIT ) break;

		//show on the screen
		apply_surface( 0, 0, pic, temp );

		//free the surface
		SDL_FreeSurface( pic );

		//show the other stuff on the screen
		//for( int i = 0; i < 4; i++ )
		//{
		//}

		//blow it up
		Increase( bigscreen, temp, 2 );

		//flip it
		SDL_Flip( bigscreen );

		//delay
		if( frames <= 20 ) SDL_Delay( 20 + (20-frames) * 5 / 2 );
		else SDL_Delay( 20 );

		//certain things happen at these points
		if( frames == 32 )
		{
			Mix_HaltChannel( 1 );
			Mix_FreeChunk( introsound );
			SDL_Delay( 2800 );			
		}
		if( frames == 0 ) SDL_Delay( 1150 );

		//update
		frames++;

		if( temptimer.get_ticks() < 1000 / FRAMES_PER_SECOND )
        {
            SDL_Delay( ( 1000 / FRAMES_PER_SECOND ) - temptimer.get_ticks() );
        }

		//maybe you should make it so the window can be closed without crashing?
	}

}

void show_background( int level )
{
	//mkay so you could replace all the surfaces in here with one surface
	switch( level )
	{
		case 1: apply_surface( 179 - camera.x + ((camera.x - ( camera.x % 4 )) / 4 ), 8 - camera.y, colours, screen ); break;

		//walker
		case 2: apply_surface( 99 - camera.x + ((camera.x - ( camera.x % 4 )) / 4 ), 0 - camera.y + ((camera.y - ( camera.y % 4 )) / 4 ), glasses[ 14 ], screen ); break;

		//spiral(s?) 
		case 3: apply_surface( 0 - camera.x + ((camera.x - ( camera.x % 4 )) / 4 ), 0 - camera.y + ((camera.y - ( camera.y % 4 )) / 4 ), glasses[ 15 ], screen ); break;
		case 4: apply_surface( 0 - camera.x + ((camera.x - ( camera.x % 4 )) / 4 ), 20 - camera.y + ((camera.y - ( camera.y % 4 )) / 4 ), glasses[ 3 ], screen ); break;
		case 5: apply_surface( 204 - camera.x + ((camera.x - ( camera.x % 4 )) / 4 ), 0 - camera.y + ((camera.y - ( camera.y % 4 )) / 4 ), glasses[ 12 ], screen ); break;

		//8-point star series
		case 6: apply_surface( 0, 0, greencrinkledrhombs, screen ); break;
		case 7: apply_surface( 0, 0, greencrinkledrhombs, screen ); break;
		case 8: apply_surface( 0, 0, greencrinkledrhombs, screen ); break;

		//loop
		case 9: apply_surface( 121, 5, glasses[ 11 ], screen ); break;

		//pincer 
		case 10: apply_surface( 77 - camera.x + ((camera.x - ( camera.x % 4 )) / 4 ), 62 - camera.y + ((camera.y - ( camera.y % 4 )) / 4 ), glasses[ 13 ], screen ); break;

		//square
		case 11: apply_surface( 0 - camera.x + ((camera.x - ( camera.x % 4 )) / 4 ), 26 - camera.y + ((camera.y - ( camera.y % 4 )) / 4 ), glasses[ 16 ], screen ); break;

		//pyramid
		case 12: apply_surface( 80 - camera.x + ((camera.x - ( camera.x % 4 )) / 4 ), 0, glasses[ 0 ], screen ); break;

		//wall
		case 13: apply_surface( 0 - camera.x + ((camera.x - ( camera.x % 4 )) / 4 ), 0 - camera.y + ((camera.y - ( camera.y % 4 )) / 4 ), glasses[ 10 ], screen ); break;

		//hourglass shaped levels
		case 14: apply_surface( 0 - 4 - camera.x + ((camera.x - ( camera.x % 4 )) / 4 ), 0, glasses[ 8 ], screen ); break;
		case 15: apply_surface( 0 - 4 - camera.x + ((camera.x - ( camera.x % 4 )) / 4 ), 0, glasses[ 8 ], screen ); break;
		case 16: apply_surface( 0 - 4 - camera.x + ((camera.x - ( camera.x % 4 )) / 4 ), 0, glasses[ 8 ], screen ); break;
		case 17: apply_surface( 0 - 4 - camera.x + ((camera.x - ( camera.x % 4 )) / 4 ), 0, glasses[ 8 ], screen ); break;
		case 18: apply_surface( 14 - camera.x + ((camera.x - ( camera.x % 4 )) / 4 ), 0, glasses[ 8 ], screen ); break;

		//angelblock
		case 19: apply_surface( 0 - camera.x + ((camera.x - ( camera.x % 4 )) / 4 ), 0 - camera.y + ((camera.y - ( camera.y % 4 )) / 4 ), glasses[ 26 ], screen ); break;
		//case 20: apply_surface( 46 - camera.x + ((camera.x - ( camera.x % 4 )) / 4 ), 35 - camera.y + ((camera.y - ( camera.y % 4 )) / 4 ), glasses[ 25 ], screen ); break; 

		//Comparers
		case 20: apply_surface( 0 - camera.x + ((camera.x - ( camera.x % 4 )) / 4 ), 0 - camera.y + ((camera.y - ( camera.y % 4 )) / 4 ), glasses[ 26 ], screen ); break;
		case 21: apply_surface( 60 - camera.x + ((camera.x - ( camera.x % 4 )) / 4 ), 0 - camera.y + ((camera.y - ( camera.y % 4 )) / 4 ), glasses[ 25 ], screen ); break;

		//powerbeads (incl catchup)
		case 22: apply_surface( 0 - camera.x + ((camera.x - ( camera.x % 4 )) / 4 ), 0 - camera.y + ((camera.y - ( camera.y % 4 )) / 4 ), glasses[ 9 ], screen ); break;
		case 23: apply_surface( 0 - camera.x + ((camera.x - ( camera.x % 4 )) / 4 ), 4 - camera.y + ((camera.y - ( camera.y % 4 )) / 4 ), glasses[ 9 ], screen ); break;
		case 24: apply_surface( 0 - camera.x + ((camera.x - ( camera.x % 4 )) / 4 ), 0 - camera.y + ((camera.y - ( camera.y % 4 )) / 4 ), glasses[ 9 ], screen ); break;
		case 25: apply_surface( 0 - camera.x + ((camera.x - ( camera.x % 4 )) / 4 ), 100 - camera.y + ((camera.y - ( camera.y % 4 )) / 4 ), glasses[ 9 ], screen ); break;

		//relativity
		case 26: apply_surface( -237 - camera.x + ((camera.x - ( camera.x % 4 )) / 4 ), 8 - camera.y, relativitybg, screen ); break;

		//gargler
		case 27: apply_surface( 18 - camera.x + ((camera.x - ( camera.x % 4 )) / 4 ), 0 - camera.y + ((camera.y - ( camera.y % 4 )) / 4 ), glasses[ 7 ], screen ); break;

		//gargbeads (incl. Momentum
		case 29: apply_surface( 0 - camera.x, 0 - camera.y + ((camera.y - ( camera.y % 4 )) / 4 ), glasses[ 33 ], screen ); break;
		case 30: apply_surface( 0 - camera.x, 0 - camera.y + ((camera.y - ( camera.y % 4 )) / 4 ), glasses[ 33 ], screen ); break;
		case 31: apply_surface( 0 - camera.x, 0 - camera.y + ((camera.y - ( camera.y % 4 )) / 4 ), glasses[ 33 ], screen ); break;
		case 32: apply_surface( 0 - camera.x, 0 - camera.y + ((camera.y - ( camera.y % 4 )) / 4 ), glasses[ 33 ], screen ); break;
		case 33: apply_surface( 0 - camera.x, 0 - camera.y + ((camera.y - ( camera.y % 4 )) / 4 ), glasses[ 33 ], screen ); break;

		//Trapper
		case 34: apply_surface( 117 - camera.x + ((camera.x - ( camera.x % 4 )) / 4 ), 0 - camera.y + ((camera.y - ( camera.y % 4 )) / 4 ), glasses[ 6 ], screen ); break;

		//gargpincer
		case 28: apply_surface( 171 - camera.x + ((camera.x - ( camera.x % 4 )) / 4 ), 12 - camera.y + ((camera.y - ( camera.y % 4 )) / 4 ), glasses[ 5 ], screen ); break;

		//garg pattern transposers
		case 35: apply_surface( 8 - camera.x, 4 - camera.y + ((camera.y - ( camera.y % 4 )) / 4 ), glasses[ 36 ], screen ); break;
		case 36: apply_surface( 8 - camera.x, 4 - camera.y + ((camera.y - ( camera.y % 4 )) / 4 ), glasses[ 36 ], screen ); break;
		case 37: apply_surface( 8 - camera.x, 4 - camera.y + ((camera.y - ( camera.y % 4 )) / 4 ), glasses[ 36 ], screen ); break;

		//gargtraps
		case 38: apply_surface( 0, 0, glasses[ 1 ], screen ); break;
		case 39: apply_surface( 0, 0, glasses[ 1 ], screen ); break;
		case 40: apply_surface( 0, 0, glasses[ 1 ], screen ); break;

		case 41: apply_surface( -5 - camera.x + ((camera.x - ( camera.x % 4 )) / 4 ), 3 - camera.y + ((camera.y - ( camera.y % 4 )) / 4 ), glasses[ 4 ], screen ); break;
		case 42: apply_surface( -5 - camera.x + ((camera.x - ( camera.x % 4 )) / 4 ), 3 - camera.y + ((camera.y - ( camera.y % 4 )) / 4 ), glasses[ 4 ], screen ); break;
		case 43: apply_surface( -5 - camera.x + ((camera.x - ( camera.x % 4 )) / 4 ), 3 - camera.y + ((camera.y - ( camera.y % 4 )) / 4 ), glasses[ 4 ], screen ); break;
		case 44: apply_surface( -5 - camera.x + ((camera.x - ( camera.x % 4 )) / 4 ), 3 - camera.y + ((camera.y - ( camera.y % 4 )) / 4 ), glasses[ 4 ], screen ); break;
		case 45: apply_surface( -5 - camera.x + ((camera.x - ( camera.x % 4 )) / 4 ), 3 - camera.y + ((camera.y - ( camera.y % 4 )) / 4 ), glasses[ 4 ], screen ); break;

		case LAST_LEVEL: apply_surface( 0 - camera.x, 0 - camera.y, buttons, screen ); break;

		default: apply_surface( 0 - camera.x, 0 - camera.y, background, screen ); break;
	}
}


//small game loop that we use to display the menu screen. We invoke this if we've just opened the window and level > 1
bool menuscreen()
{
	//So you're looing at the loading screen. There are five numbers in a list on the screen.
	//no controls needed, this is for people who have already played the game
	//each number has a 200x120 image of the level associated with it.
	//would be easy to have the alpha of the number increase and decrease.


	SDL_Surface *loading_screen = load_image( "animations/loading_screen.png" );
	SDL_Surface *boxes = load_image( "animations/Numbered List.png" );
	SDL_Surface *expandingbox = load_image( "animations/menu selectors.png" );
	SDL_Surface *numbers = load_image( "animations/menu numbers.png" );
	SDL_Surface *glow = load_image( "animations/Glow.png" );
	SDL_Surface *screenshots = load_image( "animations/screenshots.jpg" );

	violins[ 6 ] = Mix_LoadWAV( "Sounds/Violin_C.wav" );
	violins[ 7 ] = Mix_LoadWAV( "Sounds/Violin_J.wav" );

	Mix_Volume( 5, 20 );

	//have this here too
	bool quit = false;

	//which menu item you're on. 0 is "continue", 1 is "new game"
	bool menuselection = 0;

	//which number you're on
	int selection = level;

	//this is the Y location of the list. You move the list down to increase the level selected. The number is always <= 0
	int ListLocation = -68 * (selection-1);

	//the level picture glows (something has to glow). Prob just have a grey square behind and increase+decrease alpha.

	//we have the line of boxes as a great big image.

	SDL_Rect boxclip = { 0, 0, 100, 60 };
	SDL_Rect shotbox = { 0, 120 * (selection - 1), 200, 120 };

	int GlowStrength = 0;
	int GlowVel = 0;

	Timer fps;

	while( quit == false )
    {
        //Start the frame timer
        fps.start();

		//While there's events to handle
        while( SDL_PollEvent( &event ) )
        {
			if( event.type == SDL_KEYDOWN )
			{
				switch( event.key.keysym.sym )
				{ 
					case SDLK_UP: { if( selection > 1 )    { selection--; Mix_PlayChannel( 5, violins[ 7 ], 0 ); shotbox.y = 120 * (selection - 1); } } break;
					case SDLK_DOWN: { if( selection < LAST_LEVEL ) { selection++; Mix_PlayChannel( 5, violins[ 6 ], 0 ); shotbox.y = 120 * (selection - 1); } } break;

					default: {
						loading_screen = load_image( "animations/loading_screen.png" );

						apply_surface( 0, 0, loading_screen, screen );

						Increase( bigscreen, screen, 2 );

						SDL_Flip( bigscreen );

						SDL_FreeSurface( loading_screen );

						level = selection;
						SDL_FreeSurface( loading_screen );
						SDL_FreeSurface( numbers );
						SDL_FreeSurface( expandingbox );
						SDL_FreeSurface( boxes );
						SDL_FreeSurface( screenshots );

						if( level == 1 ) openingscript = 1;
						
						return 0; }
				}
			}

            //If the user has Xed out the window
            if( event.type == SDL_QUIT )
            {
                //leave this game loop and we don't want to start the game
				quit = true;
            }
        }

		//if the list does not have the right level at the center...
		//if listlocation == 0, selection = 1. List location == -68, 
		if( ListLocation != -68 * (selection-1) )
		{
			if( ListLocation > -68 * (selection-1) ) ListLocation -= 4; //note: it needs to be a factor of 68.
			else ListLocation += 4;			
		}

		//now we start showing stuff. Loading screen, vertical line of boxes [ If selection: glowing bits, screenshot, biggest box], expanding box numbers.
		apply_surface( 0, 0, loading_screen, screen );
		apply_surface( 30, ListLocation, boxes, screen );

		//if you have a selection, we show extra stuff
		if( ListLocation == -68 * (selection-1) )
		{
			if( GlowStrength > 32 ) GlowVel--;
			else GlowVel++;

			//ideally we want a sine function for this
			GlowStrength += 0.3 * GlowVel;

			//make some things glow, and put alpha here.
			SDL_SetAlpha( glow, SDL_SRCALPHA, GlowStrength );
			apply_surface( 0, 0, glow, screen );

			boxclip.y = 0;
			apply_surface( 17, 90, expandingbox, screen, &boxclip );

			apply_surface( 140, 60, screenshots, screen, &shotbox ); //might be nice to tweak alpha
		}
		else
		{
			boxclip.y = (ListLocation % 68) / -4;
			boxclip.y *= 60;
			apply_surface( 17, 90 + ListLocation % 68, expandingbox, screen, &boxclip );

			boxclip.y = 1020 - boxclip.y;
			apply_surface( 17, 158 + ListLocation % 68, expandingbox, screen, &boxclip );
		}

		apply_surface( 30, ListLocation, numbers, screen );

		Increase( bigscreen, screen, 2 );
		
		SDL_Flip( bigscreen );

		if( fps.get_ticks() < 1000 / 60 )
        {
            SDL_Delay( ( 1000 / 60 ) - fps.get_ticks() );
        }
	}

	//we got out of that loop? never mind the game then
	return 1;
}

int main( int argc, char* args[] )
{
	
    //Quit flag
    bool quit = false;
	

	//Initialize
    if( init() == false )
    {
        return 1;
    }
	
	//what level we're on. We start on level 1. Saving is a question of changing this.
	std::ifstream savegame;
	savegame.open( "savegame.map" );
	if( savegame == NULL )
    {
		//no save file? start at the beginning. Don't show the menu screen
		savegame.close();
		level = 1;

		//also this is first so play the "opening cutscene"
		openingscript = 1;
    }
	else
	{
		savegame >> level;
		//is it a silly number? Or is it the last level, in which case we loop around?
		if( level >= LAST_LEVEL )
		{
			//start a new game!
			level = 1;
			openingscript = 1;
		}

		savegame.close();
	}

	if( level != 1 )
	{
		if( menuscreen() ) return 0; 
	}
	
	
	

	//the avatar, whose position gets changed by tile setter
	Avatar myAvatar( 200, 120, 0 );



	//The frame rate regulator
    Timer fps;

	

	//The tiles that will be used.
    Tile *tiles[ TOTAL_TILES ];	

    //The stones. Temporarily, we put them in unimportant places.
	stone *stones[ TOTAL_STONES ];

	for( int t = 0; t < TOTAL_STONES; t++ )
	{
		//putting them in the top left corner means they are non-existant. If we want some, set_tiles will alter some and leave the others.
		stones[ t ] = &stone( 0, 0 );
	}

	//the angels
	angel *angels[ TOTAL_ANGELS ];

	for( int t = 0; t < TOTAL_ANGELS; t++ )
	{
		//putting them in the top left corner means they are non-existant. If we want some, set_tiles will alter some and leave the others.
		angels[ t ] = &angel( 0, 0, 0 );
	}
	
	//The array of beads, which gets filled with null beads
	Bead *beads[ TOTAL_BEADS ];

	for( int t = 0; t < TOTAL_BEADS; t++ )
	{
		beads[ t ] = &Bead( 4, 4, 8 );
	}

	//releasing angels. the variable decides which one gets used
	bool whichparticle = 1;
	particle angelparticleA( 0, 0, 0, 8 );
	particle angelparticleB( 0, 0, 0, 8 );

	//particles. If you have many levels with killing lots angels in a row, increase the angel type ones
	particle restartparticle( LEVEL_WIDTH, LEVEL_HEIGHT, 3, 8 ); //when an angel dies in a certain level, it relocates you
	particle finalparticle( 0, 0, 4, 8 );
	particle puff( 0, 0, 1, 8 );
	particle *sparks[ 16 ];
	particle *feathers[ 32 ];
	particle *trail[ 16 ];
	particle *gargpuffs[ 32 ];	

	for( int t = 0; t < 32; t++ ) gargpuffs[ t ] = new particle( 0, 0, 10, 8 );

	for( int t = 0; t < 16; t++ ) sparks[ t ] = new particle( 0, 0, 2, 8 );

	for( int t = 0; t < 16; t++ ) trail[ t ] = new particle( 0, 0, 9, 8 );

	for( int t = 0; t < 32; t++ ) feathers[ t ] = new particle( camera.x + rand() % SCREEN_WIDTH, camera.y - 10 + rand() % SCREEN_HEIGHT, 6, rand() % 3 + 1 );

    //Load the files
    if( load_files() == false )
    {
        return 1;
    }

    clip_sheets();


	

	//Set the tiles
    if( set_tiles( tiles, &myAvatar, angels, stones, &quit, 1 ) == false )
    {
        return 1;
    }

	//set up a frame counter. Maybe it should be more than an int? It gets big very fast. You could do framecount %= 64 or something at some point, but would anything fuck up?
	int framecount = 0;

	

	//this value will be used to make a new bead. 8 means we don't want one.
	int newbead = 8;
	//this is a dummy value that we have so that we don't have to call handle_input twice.
	int holdbead;


	
	restart = 0;

	//very hacky. this variable stores the thing we're adjusting the camera to in the last level
	int camerarecord = 1000;
	

	//indiecade description
	apply_surface( 0, 0, load_image( "animations/eraser.png" ), bigscreen );

	//can you do this?
	Mix_AllocateChannels ( 16 );

	//set the volume for the rest of them
	for( int i = 1; i < 16; i++ )
	{
		Mix_Volume( i, MIX_MAX_VOLUME );
	}

	play_opening();

	//the sound of the game
	//Mix_PlayChannel( 0, noise, -1 );

    //While the user hasn't quit
    while( quit == false )
    {
        //Start the frame timer
        fps.start();

		//While there's events to handle
        while( SDL_PollEvent( &event ) )
        {
			int templevel = level;

			//Handle events for the avatar; gets a new bead if the player wants one. But only if we're not shocked by an angel or it isn't the very very end of the game
			if( script == 0 || ( script == 4 && camera.y < 92 ) ) holdbead = myAvatar.handle_input();

			if( templevel != level ) restart = 1;

			if( holdbead != 8 ) newbead = holdbead;			

            //If the user has Xed out the window
            if( event.type == SDL_QUIT )
            {
                //Quit the program
                quit = true;
            }
        }

		//restart stuff

		//only kill the avatar if we've already loaded at least one fram!
		/*
		if( framecount > 0 )
		{
			for( int t = 0; t < TOTAL_ANGELS; t++ )
			{
				//if scan returns true for any of them then restart
				if( angels[ t ]->scan( tiles, stones ) )
				{
					restart = 1;

					//play a sound
					for( int s = 0; s < 8; s++ )
					{
						Mix_HaltChannel( s );				
					}
					Mix_PlayChannel( 8, glock_C, 0 );
					Mix_PlayChannel( 9, glock_D, 0 );
					Mix_PlayChannel( 10, glock_E, 0 );
					Mix_PlayChannel( 11, glock_F, 0 );
					Mix_PlayChannel( 12, glock_G, 0 );
					Mix_PlayChannel( 13, glock_H, 0 );
					Mix_PlayChannel( 14, glock_I, 0 );
					Mix_PlayChannel( 15, glock_J, 0 );
				}
			}
		}
		*/

		//this seems to work but expect the unexpected. It is really is just what it looks like.
		if( restart )
		{
			Increase( bigscreen, wall, 2 );

			SDL_Delay( 340 );

			//avatar shouldn't throw the bead they were about to
			newbead = 8;

			//nullify the beads.
			for( int t = 0; t < TOTAL_BEADS; t++ )
			{
				//delete what's there
				beads[ t ]->change( 4, 4, 8 );
			}

			//make sure we don't just start continually restarting! reset restart when you've done the level transition, just before the end of the first frame of this session.

			//reload everything
			set_tiles( tiles, &myAvatar, angels, stones, &quit, 0 );

			if( camera.x < 16 ) Torusrightward = 1;

			//some spawning is based on camera location
			myAvatar.set_camera();

			//put the particles out of the way
			puff.relocate( LEVEL_WIDTH, LEVEL_HEIGHT, 8, 0, 0 );
			angelparticleA.relocate( LEVEL_WIDTH, LEVEL_HEIGHT, 8, 0, 0 );
			angelparticleB.relocate( LEVEL_WIDTH, LEVEL_HEIGHT, 8, 0, 0 );
			for( int t = 0; t < 16; t++ ) sparks[ t ]->relocate( LEVEL_WIDTH, LEVEL_HEIGHT, 8, 0, 0 );
			for( int t = 0; t < 16; t++ ) trail[ t ]->relocate( LEVEL_WIDTH, LEVEL_HEIGHT, 8, 0, 0 );
			for( int t = 0; t < 32; t++ ) feathers[ t ]->relocate( LEVEL_WIDTH, LEVEL_HEIGHT, 8, 0, 0 );
			for( int t = 0; t < 32; t++ ) gargpuffs[ t ]->relocate( LEVEL_WIDTH, LEVEL_HEIGHT, 8, 0, 0 );
			restartparticle.relocate( LEVEL_WIDTH, LEVEL_HEIGHT, 8, 0, 0 );
		}

		//some specific things for the last level
		if( level == LAST_LEVEL )
		{
			//dishonest switcheroo, but only if the angel's in the right place
			if( (beads[ 0 ]->rightplace( 1 ) || beads[ 1 ]->rightplace( 1 )) && angels[ 0 ]->get_x() != 0 )
			{
				//delete the angel
				angels[ 0 ] = new angel( 0, 0, 0 );				

				//put in the special particle
				finalparticle.relocate( 224, 180, 5, 0 );

				//could you also get rid of the unseemly tile here?
				delete tiles[ 43 * 512 + 59 ];
				tiles[ 43 * 512 + 59 ] = new Tile( 59 * TILE_WIDTH, 43 * 2048, 4, 0 );

				//and change these
				pressedQ = 0;
				pressedW = 0;
				pressedE = 0;
				pressedA = 0;
				pressedD = 0;
				pressedZ = 0;
				pressedX = 0;
				pressedC = 0;
			}

			//and we do the continuous falling thing, provided something's been shot and we're past the hug
			if( camera.y == 92 )
			{
				if(
					/*
					!( pressedQ || pressedE )
				||  !( pressedA || pressedD )
				||  !( pressedZ || pressedC )
				||  !pressedW || !pressedX )
					*/
					3 > pressedQ + pressedE + pressedA + pressedD + pressedC + pressedZ + pressedX
					)
				{
					//change the y co ordinate of all these objects
					myAvatar.loopify();

					stones[ 0 ]->loopify();
					stones[ 1 ]->loopify();

					beads[ 0 ]->loopify();
					beads[ 1 ]->loopify();

					finalparticle.loopify();

					for( int t = 0; t < 16; t++ ) sparks[ t ]->loopify(); //If you just show any one of them, it always shows the one that exists. Don't forget: relocation functions
					for( int t = 0; t < 16; t++ ) trail[ t ]->loopify();
					//for( int t = 0; t < 32; t++ ) feathers[ t ]->loopify();
					puff.loopify();
				}
				else //shocked again, irreperably
				script = 4;
			}

			//and if you're at the bottom
			if( stones[ 0 ]->get_on() == 0 )
			{
				//first let the angels sink in
				SDL_Delay( 4000 );

				//few more pictures
				play_ending();

				//then that's it
				quit = 1;
			}
		}




		//Move the stones. Crucially, this happens before beads, lessening the likelihood of overlap. And before the avatar so the avatar can descend too.
		for( int t = 0; t < TOTAL_STONES; t++ )
        {
            stones[ t ]->move( tiles, angels, framecount );
        }

		//Move the avatar. Happens before bead creation because you don't want a frame where a bead is created in a place where the avatar is not.
        myAvatar.move( tiles, stones, framecount );

        //Set the camera. Don't ever take this away from avatar.move: much of the program relies on getting avatar's location from camera's.
        myAvatar.set_camera();

		//oh! but if you're after that last part in the last level,
		if( level == LAST_LEVEL && camera.y + SCREEN_HEIGHT > LEVEL_HEIGHT - TILE_HEIGHT * 7)
		{
			//if the number is absurd, we've not yet recorded. That means this is the first frame, so we need to
			if( camerarecord == 1000 )
			{
				camerarecord = camera.x - (camera.x % 4) + 4;
			}

			//if it's gotten to 4, then we're done and the camera is in place
			if( camerarecord != 36 )
			{
				//move it in the appropriate direction
				if( camerarecord < 36 ) camerarecord += 4;
				else camerarecord -= 4;
			}

			//update
			camera.x = camerarecord;

			//need to put y in the right place as well
			if( camera.y + SCREEN_HEIGHT > LEVEL_HEIGHT - TILE_HEIGHT * 7 ) camera.y = LEVEL_HEIGHT - SCREEN_HEIGHT - TILE_HEIGHT * 7;
		}

		//if it's a time when the player can make a bead, play a beat
		//if( !(framecount % 16) ) Mix_PlayChannel( 7, beat, 0 );

		//If the input handler has told us that we want a bead. This is before the beads move so you can get it out as fast as possible.
		//and the player is in sync
		if( newbead != 8 && framecount % 16 == 15 )
		{
			//Disappeared beads are signified by dir ==8, x == 0, y == 0.

			//you're about to make a bead vanish; make some smoke
			beads[ beadcursor ]->vanish( &puff );
			if( beadcursor ) white = 0;
			else white = 1;

			//when you have a variable saying "avatar is at the bottom of the screen [so have trails for bullets]" put a conditional here.
			//create a bead in the least-recently used location. Change this as appropriate to get the real starting location
			beads[ beadcursor ] = new Bead( camera.x + ( SCREEN_WIDTH / 2 ), camera.y + ( SCREEN_HEIGHT / 2 ), newbead );

			//play a sound
			Mix_PlayChannel( 5, violins[ newbead ], 0 );

			//warning?
			if( camera.x % 4 != 0 || camera.x % 4 != 0 ) return 1;

			//make the least-recently used into the most-recently used, which is what it is
			beadcursor++;

			//loop around. This has been altered for the trailer.
			if( beadcursor == TOTAL_BEADS ) beadcursor = 0;

			//so the bead is taken care of
			newbead = 8;
		}

		//AI. Before the beads so that they are reacting to the previous frame - we see what they're reacting to. Happens after stones to avoid mishaps
		for( int t = 0; t < TOTAL_ANGELS; t++ )
		{
			//this part works out what directions the beads allow us.
			if( angels[ t ]->get_on() ) angels[ t ]->check( 0, beads, tiles, stones, angels );		
		}

		//think() prioritizes directions and calls move()
		for( int t = 0; t < TOTAL_ANGELS; t++ )
		{
			//they may get in each other's way.
			//inside the move function, the think function of an obstructing angel shall be called. Then ones who have had their think function called will be skipped here
			//but it's not just a case of that. It ought to be that ones that MIGHT be obstructed should get called first, unless they're mutually obstucting.
			if( angels[ t ]->get_on() ) angels[ t ]->think( tiles, stones, beads, angels );
		}

		//Move the beads. You'll have something to sort out if you ever want to put this before stones. You send it that particular spark to ensure no repeats
		for( int t = 0; t < TOTAL_BEADS; t++ )
        {
			if( whichparticle ) { beads[ t ]->move( 0, tiles, stones, angels, sparks, &angelparticleA, t, trail ); whichparticle = 0; }
			else { beads[ t ]->move( 0, tiles, stones, angels, sparks, &angelparticleB, t, trail ); whichparticle = 1; }
        }

		//but we want it to be that if there's a bullet wall and you're going downright on "wall", angel dies
		if( level == 13 && angels[ 0 ]->get_y() == 144 && ( beads[ 0 ]->rightplace( 0 ) || beads[ 1 ]->rightplace( 0 ) ) )
		{
			angels[ 0 ]->kill( angels, &angelparticleA );
		}
		




		
		//start with a black sheet to remove artifacts. Do you have to free the previous screen or anything like that?
		//something fucking weird happens when you try to turn screen into an array of pixels... unless you do this =/
		//delete screen;
		apply_surface( 0, 0, black, screen );

		show_background( level );

		if( level != LAST_LEVEL ) for( int t = 0; t < 32; t++ ) feathers[ t ]->show();

		//show the particles
		angelparticleA.show( &restartparticle );
		angelparticleB.show( &restartparticle );

		//Show the fat lead tiles
		for( int t = 0; t < TOTAL_TILES; t++ )
		{
			tiles[ t ]->show( 1, 0 );
		}

		//Show the tiles
		for( int t = 0; t < TOTAL_TILES; t++ )
		{
			tiles[ t ]->show( 0, 0 );
		}

		//Show the flint wall tiles
		for( int t = 0; t < TOTAL_TILES; t++ )
		{
			tiles[ t ]->show( 0, 1 );
		}

		for( int t = 0; t < 16; t++ ) sparks[ t ]->show( &restartparticle ); //If you just show any one of them, it always shows the one that exists. Don't forget: relocation functions
		for( int t = 0; t < 16; t++ ) trail[ t ]->show( &restartparticle );
		
		puff.show( &restartparticle );
		
		

		for( int t = 0; t < TOTAL_ANGELS; t++ )
		{
			if( angels[ t ]->get_on() ) angels[ t ]->show( stones, framecount );
		}

		//Show the stones
		for( int t = 0; t < TOTAL_STONES; t++ )
        {
			stones[ t ]->show( gargpuffs );
        }

		for( int t = 0; t < 32; t++ ) gargpuffs[ t ]->show( &restartparticle );

        //Show the Avatar on the screen
        //myAvatar.show( framecount, newbead );


		

		//the functions in this if statement show the beads. if they're in the same place it's special
		if( beads[0]->show( 0, framecount ) == beads[1]->show( 1, framecount ) ) beads[ 0 ]->show( 2, framecount );

		//frame's done. We have this after showings because some of these showings are based on framecount!
		framecount++;


		

		

		//what will happen with the texture? Well, the actual blocks shall be "transparent". So graphics() will ignore both transparency and blackness.
		//what's currently the gameplay layer will be superimposed on a texture, which will be seen through the "block" parts.
		//then the graphics function takes data from screen, and imposes rays on wall.

		
		
		//apply the right part of the wood texture. Is there anything you can do to line it with lead?
		apply_surface( 0 - camera.x, 0 - camera.y, wood, wall );

		//apply_surface( 0, 0, frontwood, screen );

		//put the screen, with the blocks cut out, on top of that
		apply_surface( 0, 0, screen, wall );

		

		//make it look nice
		//graphics( screen, wall );


		//then this weird one
		if( level == LAST_LEVEL )
		{
			finalparticle.show( &restartparticle );
		}

		//These go on top for the time being.
		
		myAvatar.show( framecount, newbead, trail );

		Show_ControlKeys();

		

		if( level == 13 && !hadprompt13 ) //where we learn to restart
		{
			if(angels[ 0 ]->get_y() > 200 )
			{
				restartparticle.relocate( 219, 164, 0, 0 );

				//sticking this in the "pressedR" place works, though fuck!
				hadprompt13 = 1;
			}
		}
		
		restartparticle.show( &restartparticle );  




		//if we've just changed level and come to the end of the first frame we play the level transition
		//(to clarify, the if( advance ) thing happens, then we loop around and set_tiles, then this happens.
		if( restart )
		{
			restart = 0;
			
			//if the NEW level has a floor tile in the top left corner, that's what designates a video play.
			if( tiles[ 0 ]->get_type() == 3 && framecount == 1 )
			{
				//which should it be? depends on when we find the next floor tile
				if( tiles[ 1 ]->get_type() == 3 )
				{
					//Jack's animation
					play_video();
				}
				else
				if( tiles[ 2 ]->get_type() == 3 )
				{
					//Torus
					play_Torusvideo();
				}
				else
				if( tiles[ 3 ]->get_type() == 3 )
				{
					//gargbead1
					play_garbead1video();
				}
				else
				if( tiles[ 4 ]->get_type() == 3 )
				{
					//gargbead2
					play_garbead2video();
				}
				//flower?

				
			}
			else
			
			{
				//take our first frame of this level and put it on the strip we're about to go through
				apply_surface( 800, 0, wall, transitionstrip );

				//play the transition. Maybe you should have reverse for restarting?
				if( framecount == 1 ) level_transition( &fps );
			}
		}

		//if we need to move level!
		if( advance )
		{
			level++;
			restart = 1;

			framecount = 0;

			//avatar shouldn't throw the bead they were about to
			newbead = 8;

			std::ofstream savegame( "savegame.map" );
			if( savegame == NULL )
			{
				return 1;

				//output: unable to save! If you want to start again at this level, open up notepad and make a file called "savegame.map"
			}
			savegame << level;
			if( savegame.fail() == true )
			{
				//Stop loading map
				savegame.close();
				return false;
			}
			savegame.close();

			//apply the current game screen to the transition strip.
			apply_surface( 0, 0, wall, transitionstrip );

			//don't want to keep going!
			advance = 0;
		}

		

		//this function is as expensive as the entire gameplay part of the game!
		Increase( bigscreen, wall, 2 );
		//apply_surface( ( ACTUAL_SCREEN_WIDTH - SCREEN_WIDTH * SCALE ) / 2, ( ACTUAL_SCREEN_HEIGHT - SCREEN_HEIGHT * SCALE ) / 2, screen, bigscreen );
		//apply_surface( 0,  0, screen, bigscreen );

		

        //Update the screen
        if( SDL_Flip( bigscreen ) == -1 )
        {
            return 1;
        }

        //Cap the frame rate
        if( fps.get_ticks() < 1000 / FRAMES_PER_SECOND )
        {
            SDL_Delay( ( 1000 / FRAMES_PER_SECOND ) - fps.get_ticks() );
        }
		//else
		//if( framecount > 100 ) return 1; //if it's taking a long time to render the frame... framecount measurement so the crash out isn't immediate
	}

    //Clean up
    clean_up( tiles, stones, beads, angels, feathers );


    return 0;
}